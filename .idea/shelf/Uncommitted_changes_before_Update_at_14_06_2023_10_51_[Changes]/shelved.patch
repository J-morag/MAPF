Index: src/main/java/BasicMAPF/Instances/Maps/GraphMap.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package BasicMAPF.Instances.Maps;\r\n\r\nimport BasicMAPF.Instances.Maps.Coordinates.I_Coordinate;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * Represents a {@link I_Map map} as an abstract graph. This implementation can, in principle, support any domain -\r\n * maps representing n dimensional space, any connectivity function, disjoint sub-graphs.\r\n *\r\n * Space complexity:\r\n * This implementation requires the entire graph to be built at initialization. For very large, sparse maps, this may\r\n * pose a space complexity challenge. Example: A 1000x1000x1000 map with just one agent, whose source and target are\r\n * adjacent.\r\n */\r\npublic class GraphMap implements I_ExplicitMap {\r\n\r\n    private final HashMap<I_Coordinate, GraphMapVertex> allGraphLocations;\r\n    private final boolean isStronglyConnected;\r\n\r\n    /**\r\n     * Initialization in {@link MapFactory}.\r\n     * @param allGraphVertices a {@link HashMap} containing all locations in the graph.\r\n     */\r\n    GraphMap(HashMap<I_Coordinate, GraphMapVertex> allGraphVertices) {\r\n        this(allGraphVertices, null);\r\n    }\r\n\r\n    /**\r\n     * Initialization in {@link MapFactory}.\r\n     * @param allGraphVertices a {@link HashMap} containing all locations in the graph.\r\n     * @param isStronglyConnected - if the graph can be assumed to be strongly connected.\r\n     */\r\n    GraphMap(HashMap<I_Coordinate, GraphMapVertex> allGraphVertices, Boolean isStronglyConnected) {\r\n        this.allGraphLocations = allGraphVertices;\r\n        this.isStronglyConnected = Objects.requireNonNullElse(isStronglyConnected, true);\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link GraphMapVertex} for the given {@link I_Coordinate}.\r\n     * @param coordinate the {@link I_Coordinate} of the {@link GraphMapVertex}.\r\n     * @return the {@link GraphMapVertex} for the given {@link I_Coordinate}.\r\n     */\r\n    @Override\r\n    public GraphMapVertex getMapLocation(I_Coordinate coordinate) {\r\n        return allGraphLocations.get(coordinate);\r\n    }\r\n\r\n    @Override\r\n    public boolean isValidCoordinate(I_Coordinate coordinate) {\r\n        return this.allGraphLocations.containsKey(coordinate);\r\n    }\r\n\r\n    @Override\r\n    public I_Map getSubmapWithout(Collection<? extends I_Location> mapLocations) {\r\n        // have to rebuild the entire map to remove the removed vertices from the neighbour lists of remaining vertices.\r\n\r\n        HashMap<I_Coordinate, GraphMapVertex> vertexMappings = new HashMap<>();\r\n        // populate with stub vertices (copies), except for vertices that we want to remove\r\n        for (Map.Entry<I_Coordinate, GraphMapVertex> pair : this.allGraphLocations.entrySet()) {\r\n            if(!mapLocations.contains(pair.getValue())){\r\n                vertexMappings.put(pair.getKey(), new GraphMapVertex(pair.getValue().locationType, pair.getKey()));\r\n            }\r\n        }\r\n        // now iterate over original vertices and copy over their neighbors, except for neighbors that were removed.\r\n        for (Map.Entry<I_Coordinate, GraphMapVertex> pair : this.allGraphLocations.entrySet()) {\r\n            I_Coordinate coor = pair.getKey();\r\n            GraphMapVertex originalVertex = pair.getValue();\r\n            if(!mapLocations.contains(originalVertex)){\r\n                GraphMapVertex newVertex = vertexMappings.get(coor);\r\n                List<GraphMapVertex> neighbors = new ArrayList<>();\r\n                for (I_Location neighbor : originalVertex.outgoingEdges) {\r\n                    if (! mapLocations.contains(neighbor)){\r\n                        // getting the neighbor from the new vertices, not the original ones.\r\n                        neighbors.add(vertexMappings.get(neighbor.getCoordinate()));\r\n                    }\r\n                }\r\n                newVertex.setNeighbors(neighbors.toArray(new GraphMapVertex[0]));\r\n            }\r\n        }\r\n        return new GraphMap(vertexMappings);\r\n    }\r\n\r\n    public int getNumMapLocations(){\r\n        return allGraphLocations.size();\r\n    }\r\n\r\n\r\n    /**\r\n     * O(n)\r\n     */\r\n    @Override\r\n    public Collection<? extends I_Location> getAllLocations() {\r\n        return new ArrayList<>(this.allGraphLocations.values());\r\n    }\r\n\r\n    @Override\r\n    public boolean isStronglyConnected() {\r\n        return this.isStronglyConnected;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/BasicMAPF/Instances/Maps/GraphMap.java b/src/main/java/BasicMAPF/Instances/Maps/GraphMap.java
--- a/src/main/java/BasicMAPF/Instances/Maps/GraphMap.java	(revision b7dee42a7e06e50107bd2d08be8437bc03f0d8b2)
+++ b/src/main/java/BasicMAPF/Instances/Maps/GraphMap.java	(date 1686320951919)
@@ -46,6 +46,11 @@
         return allGraphLocations.get(coordinate);
     }
 
+    @Override
+    public HashMap<I_Coordinate, GraphMapVertex> getAllGraphLocations(){
+        return allGraphLocations;
+    }
+
     @Override
     public boolean isValidCoordinate(I_Coordinate coordinate) {
         return this.allGraphLocations.containsKey(coordinate);
Index: src/main/java/BasicMAPF/Solvers/AStar/SingleAgentAStar_Solver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package BasicMAPF.Solvers.AStar;\r\n\r\nimport BasicMAPF.Instances.Agent;\r\nimport BasicMAPF.Instances.MAPF_Instance;\r\nimport BasicMAPF.Instances.Maps.Coordinates.I_Coordinate;\r\nimport BasicMAPF.Instances.Maps.Enum_MapLocationType;\r\nimport BasicMAPF.Instances.Maps.I_Map;\r\nimport BasicMAPF.Instances.Maps.I_Location;\r\nimport BasicMAPF.Solvers.AStar.CostsAndHeuristics.AStarGAndH;\r\nimport BasicMAPF.Solvers.AStar.CostsAndHeuristics.UnitCostsAndManhattanDistance;\r\nimport BasicMAPF.Solvers.AStar.GoalConditions.I_AStarGoalCondition;\r\nimport BasicMAPF.Solvers.AStar.GoalConditions.SingleTargetCoordinateGoalCondition;\r\nimport BasicMAPF.Solvers.ConstraintsAndConflicts.ConflictManagement.ConflictAvoidance.I_ConflictAvoidanceTable;\r\nimport Environment.Metrics.InstanceReport;\r\nimport BasicMAPF.Solvers.*;\r\nimport BasicMAPF.Solvers.ConstraintsAndConflicts.Constraint.ConstraintSet;\r\nimport org.jetbrains.annotations.NotNull;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * An A* solver that only solves single agent problems. It assumes the first {@link Agent} from {@link MAPF_Instance instances}\r\n * that it is given is the agent to solve for.\r\n * By default, it uses {@link I_Coordinate#distance(I_Coordinate)} as a heuristic.\r\n */\r\npublic class SingleAgentAStar_Solver extends A_Solver {\r\n\r\n    protected static final int DEFAULT_PROBLEM_START_TIME = 0;\r\n    private final Comparator<AStarState> stateFComparator = new TieBreakingForLessConflictsAndHigherG();\r\n    private static final Comparator<AStarState> equalStatesDiscriminator = new TieBreakingForLowerGAndLessConflicts();\r\n\r\n    public boolean agentsStayAtGoal;\r\n\r\n    private ConstraintSet constraints;\r\n    private AStarGAndH gAndH;\r\n    private final I_OpenList<AStarState> openList = new OpenListTree<>(stateFComparator);\r\n    private final Set<AStarState> closed = new HashSet<>();\r\n    private Agent agent;\r\n    private I_Map map;\r\n    private SingleAgentPlan existingPlan;\r\n    private Solution existingSolution;\r\n    private I_ConflictAvoidanceTable conflictAvoidanceTable;\r\n    public I_Coordinate sourceCoor;\r\n    public I_Coordinate targetCoor;\r\n    public I_AStarGoalCondition goalCondition;\r\n    /**\r\n     * Not real-world time. The problem's start time.\r\n     */\r\n    private int problemStartTime;\r\n    private int expandedNodes;\r\n    private int generatedNodes;\r\n    /**\r\n     * Maximum allowed f value ({@link SingleAgentPlan} cost). Will stop and return null if proved that it cannot be found.\r\n     */\r\n    private float fBudget;\r\n\r\n    public SingleAgentAStar_Solver() {this(null);}\r\n\r\n    public SingleAgentAStar_Solver(Boolean agentsStayAtGoal) {\r\n        super.name = \"AStar\";\r\n        this.agentsStayAtGoal = Objects.requireNonNullElse(agentsStayAtGoal, true);\r\n    }\r\n    /*  = set up =  */\r\n\r\n    protected void init(MAPF_Instance instance, RunParameters runParameters){\r\n        super.init(instance, runParameters);\r\n\r\n        this.constraints = runParameters.constraints == null ? new ConstraintSet(): runParameters.constraints;\r\n        this.agent = instance.agents.get(0);\r\n        this.map = instance.map;\r\n\r\n        if(runParameters.existingSolution != null){\r\n            this.existingSolution = runParameters.existingSolution;\r\n            if(runParameters.existingSolution.getPlanFor(this.agent) != null){\r\n                this.existingPlan = runParameters.existingSolution.getPlanFor(this.agent);\r\n                this.problemStartTime = this.existingPlan.getEndTime();\r\n            }\r\n            else {\r\n                this.existingPlan = new SingleAgentPlan(this.agent);\r\n                this.existingSolution.putPlan(this.existingPlan);\r\n                this.problemStartTime = DEFAULT_PROBLEM_START_TIME;\r\n            }\r\n        }\r\n        else{\r\n            // make a new, empty solution, with a new, empty, plan\r\n            this.existingSolution = new Solution();\r\n            this.existingPlan = new SingleAgentPlan(this.agent);\r\n            this.existingSolution.putPlan(this.existingPlan);\r\n        }\r\n\r\n        if(runParameters instanceof RunParameters_SAAStar parameters\r\n                && ((RunParameters_SAAStar) runParameters).problemStartTime >= 0){\r\n            this.problemStartTime = parameters.problemStartTime;\r\n        }\r\n\r\n        if(runParameters instanceof RunParameters_SAAStar parameters\r\n                && ((RunParameters_SAAStar) runParameters).conflictAvoidanceTable != null){\r\n            this.conflictAvoidanceTable = parameters.conflictAvoidanceTable;\r\n        }\r\n        // else keep the value that it has already been initialised with (above)\r\n\r\n        if(runParameters instanceof RunParameters_SAAStar parameters){\r\n            this.sourceCoor = parameters.sourceCoor != null ? parameters.sourceCoor : agent.source;\r\n            this.targetCoor = parameters.targetCoor != null ? parameters.targetCoor : agent.target;\r\n        }\r\n        else{\r\n            this.sourceCoor = agent.source;\r\n            this.targetCoor = agent.target;\r\n        }\r\n\r\n        if(runParameters instanceof RunParameters_SAAStar parameters\r\n                && parameters.goalCondition != null){\r\n            this.goalCondition = parameters.goalCondition;\r\n        }\r\n        else{\r\n            this.goalCondition = new SingleTargetCoordinateGoalCondition(this.targetCoor);\r\n        }\r\n\r\n        if(runParameters instanceof RunParameters_SAAStar parameters\r\n                && ((RunParameters_SAAStar) runParameters).heuristicFunction != null){\r\n            this.gAndH = parameters.heuristicFunction;\r\n        }\r\n        else{\r\n            this.gAndH = new UnitCostsAndManhattanDistance(this.targetCoor);\r\n        }\r\n        if (! this.gAndH.isConsistent()){\r\n            throw new IllegalArgumentException(\"Support for inconsistent heuristic is not implemented.\");\r\n        }\r\n\r\n        if(runParameters instanceof RunParameters_SAAStar parameters){\r\n            this.fBudget = parameters.fBudget;\r\n        }\r\n        else{\r\n            this.fBudget = Float.POSITIVE_INFINITY;\r\n        }\r\n\r\n        this.expandedNodes = 0;\r\n        this.generatedNodes = 0;\r\n    }\r\n\r\n    /*  = A* algorithm =  */\r\n\r\n    @Override\r\n    protected Solution runAlgorithm(MAPF_Instance instance, RunParameters parameters) {\r\n        return solveAStar();\r\n    }\r\n\r\n    /**\r\n     * Solves AStar for a single agent.\r\n     * Assumes just 1 goal {@link I_Location location} - otherwise there may be problems when accounting for constraints\r\n     * at goal, that come after reaching goal.\r\n     * @return a solution that contains a plan for the {@link #agent} to its goal.\r\n     */\r\n    protected Solution solveAStar() {\r\n        // if failed to init OPEN then the problem cannot be solved as defined (bad constraints? bad existing plan?)\r\n        if (!initOpen()) return null;\r\n\r\n        AStarState currentState;\r\n\r\n        while ((currentState = openList.poll()) != null){ //dequeu in the while condition\r\n            if(checkTimeout()) {return null;}\r\n            // early stopping if we already exceed fBudget.\r\n            if (currentState.getF() > fBudget) {return null;}\r\n            closed.add(currentState);\r\n\r\n            // nicetohave - change to early goal test\r\n            if (isGoalState(currentState)){\r\n                // check to see if a rejecting constraint on the goal's location exists at some point in the future,\r\n                // which would mean we can't finish the plan there and stay forever\r\n                int firstRejectionAtLocationTime = agentsStayAtGoal ? constraints.rejectsEventually(currentState.move) : -1;\r\n\r\n                if(firstRejectionAtLocationTime == -1){ // no rejections\r\n                    // update this.existingPlan which is contained in this.existingSolution\r\n                    currentState.backTracePlan(this.existingPlan);\r\n                    return this.existingSolution; // the goal is good, and we can return the plan.\r\n                }\r\n                else{ // we are rejected from the goal location at some point in the future.\r\n                    currentState.expand();\r\n                }\r\n            }\r\n            else{ //expand\r\n                currentState.expand(); //doesn't generate closed or duplicate states\r\n            }\r\n        }\r\n        return null; //no goal state found (problem unsolvable)\r\n    }\r\n\r\n    /**\r\n     * Initialises {@link #openList OPEN}.\r\n     * OPEN is not initialised with a single root state as is common. This is because states in this solver represent\r\n     * {@link Move moves} (classically - operators) rather than {@link I_Location map locations} (classically - states).\r\n     * Instead, OPEN is initialised with all possible moves from the starting position.\r\n     * @return true if OPEN was successfully initialised, else false.\r\n     */\r\n    protected boolean initOpen() {\r\n        // if the existing plan isn't empty, we start from the last move of the existing plan.\r\n        if(existingPlan.size() > 0){\r\n            Move lastExistingMove = existingPlan.moveAt(existingPlan.getEndTime());\r\n            // We assume that we cannot change the existing plan, so if it is rejected by constraints, we can't initialise OPEN.\r\n            if(constraints.rejects(lastExistingMove)) {return false;}\r\n\r\n            openList.add(new AStarState(existingPlan.moveAt(existingPlan.getEndTime()),null, 0, 0 ));\r\n        }\r\n        else { // the existing plan is empty (no existing plan)\r\n\r\n            I_Location sourceLocation = map.getMapLocation(this.sourceCoor);\r\n            // can move to neighboring locations or stay, unless this is NO_STOP location, in which case can only move\r\n            List<I_Location> neighborLocationsIncludingCurrent = new ArrayList<>(sourceLocation.outgoingEdges());\r\n            if (sourceLocation.getType() != Enum_MapLocationType.NO_STOP){\r\n                neighborLocationsIncludingCurrent.add(sourceLocation);\r\n            }\r\n\r\n            for (I_Location destination: neighborLocationsIncludingCurrent) {\r\n                Move possibleMove = new Move(agent, problemStartTime + 1, sourceLocation, destination);\r\n                if (sourceLocation.equals(destination)){\r\n                    possibleMove.isStayAtSource = true;\r\n                }\r\n                if (constraints.accepts(possibleMove)) { //move not prohibited by existing constraint\r\n                    AStarState rootState = new AStarState(possibleMove, null, this.gAndH.cost(possibleMove), 0);\r\n                    openList.add(rootState);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        // if none of the root nodes was valid, OPEN will be empty, and thus uninitialised.\r\n        return !openList.isEmpty();\r\n    }\r\n\r\n    private boolean isGoalState(AStarState state) {\r\n        return this.goalCondition.isAGoal(state);\r\n    }\r\n\r\n    /*  = wind down =  */\r\n\r\n    protected void writeMetricsToReport(Solution solution) {\r\n        super.writeMetricsToReport(solution);\r\n\r\n        if(instanceReport != null){\r\n            instanceReport.putIntegerValue(InstanceReport.StandardFields.expandedNodesLowLevel, this.expandedNodes);\r\n            instanceReport.putIntegerValue(InstanceReport.StandardFields.generatedNodesLowLevel, this.generatedNodes);\r\n        }\r\n    }\r\n\r\n    protected void releaseMemory() {\r\n        super.releaseMemory();\r\n        this.constraints = null;\r\n        this.gAndH = null;\r\n        this.instanceReport = null;\r\n        this.openList.clear();\r\n        this.closed.clear();\r\n        this.agent = null;\r\n        this.map = null;\r\n        this.existingSolution = null;\r\n        this.existingPlan = null;\r\n        this.conflictAvoidanceTable = null;\r\n        this.sourceCoor = null;\r\n        this.targetCoor = null;\r\n        this.goalCondition = null;\r\n    }\r\n\r\n    private int numConflicts(Move move){\r\n        // TODO to support PIBT paths with tie breaking by num conflicts, may have to create duplicate nodes after\r\n        //  reaching a goal, one as a last move and one as an intermediate move, because they would have a different number of conflicts.\r\n        return conflictAvoidanceTable == null ? 0 : conflictAvoidanceTable.numConflicts(move, false);\r\n    }\r\n\r\n    /*  = inner classes =  */\r\n\r\n    public class AStarState implements Comparable<AStarState>{\r\n\r\n        /**\r\n         * Needed to enforce total ordering on nodes, which is needed to make node expansions fully deterministic. That\r\n         * is to say, if all tie breaking methods still result in equality, tie break for using serialID.\r\n         */\r\n        private final int serialID = SingleAgentAStar_Solver.this.generatedNodes++; // take and increment\r\n        public final Move move;\r\n        private final AStarState prev;\r\n        private final int g;\r\n        private final float h;\r\n//        /**\r\n//         * If true we search both the space and the time dimension.\r\n//         */\r\n//        private final boolean timeDimension;\r\n        /**\r\n         * counts the number of conflicts generated by this node and all its ancestors.\r\n         */\r\n        private final int conflicts;\r\n\r\n        public AStarState(Move move, AStarState prevState, int g, int conflicts\r\n//                , boolean timeDimension\r\n        ) {\r\n            this.move = move;\r\n            this.prev = prevState;\r\n            this.g = g;\r\n\r\n            this.conflicts = conflicts;\r\n//            this.timeDimension = timeDimension;\r\n\r\n            // must call these last, since they need the other fields to be initialized already.\r\n            this.h = calcH();\r\n        }\r\n\r\n\r\n        /*  = getters =  */\r\n        public Move getMove() {\r\n            return move;\r\n        }\r\n\r\n        public AStarState getPrev() {\r\n            return prev;\r\n        }\r\n\r\n        public int getG() {\r\n            return g;\r\n        }\r\n\r\n        public int getConflicts() {\r\n            return conflicts;\r\n        }\r\n\r\n        public float getF(){\r\n            return g + h;\r\n        }\r\n\r\n        private float calcH() {\r\n            return SingleAgentAStar_Solver.this.gAndH.getH(this);\r\n        }\r\n\r\n        public void expand() {\r\n            expandedNodes++;\r\n            // can move to neighboring locations or stay put\r\n            List<I_Location> neighborLocationsIncludingCurrent = new ArrayList<>(this.move.currLocation.outgoingEdges());\r\n            // no point to do stay moves or search the time dimension after the time of last constraint.\r\n            // this makes A* complete even when there are goal constraints (infinite constraints)\r\n            boolean afterLastConstraint = this.move.timeNow > constraints.getLastConstraintTime();\r\n            if (!afterLastConstraint &&\r\n                    !this.move.currLocation.getType().equals(Enum_MapLocationType.NO_STOP)){ // can't stay on NO_STOP\r\n                neighborLocationsIncludingCurrent.add(this.move.currLocation);\r\n            }\r\n\r\n            for (I_Location destination: neighborLocationsIncludingCurrent){\r\n                // give all moves after last constraint time the same time so that they're equal. patch the plan later to correct times\r\n                Move possibleMove = new Move(this.move.agent, !afterLastConstraint ? this.move.timeNow + 1 : this.move.timeNow,\r\n                        this.move.currLocation, destination);\r\n                if (possibleMove.prevLocation.equals(possibleMove.currLocation) && this.move.isStayAtSource){\r\n                    possibleMove.isStayAtSource = true;\r\n                }\r\n\r\n                // move not prohibited by existing constraint\r\n                if(constraints.accepts(possibleMove)){\r\n                    AStarState child = new AStarState(possibleMove, this,\r\n                            this.g + SingleAgentAStar_Solver.this.gAndH.cost(possibleMove),\r\n                            conflicts + numConflicts(possibleMove));\r\n\r\n                    AStarState existingState;\r\n                    if(closed.contains(child)){ // state visited already\r\n                        // TODO for inconsistent heuristics - if the new one has a lower f, remove the old one from closed\r\n                        // and add the new one to open\r\n                    }\r\n                    else if(null != (existingState = openList.get(child)) ){ //an equal state is waiting in open\r\n                        //keep the one with min G\r\n                        keepTheStateWithMinG(child, existingState); //O(LOGn)\r\n                    }\r\n                    else{ // it's a new state\r\n                        openList.add(child);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        private void keepTheStateWithMinG(AStarState newState, AStarState existingState) {\r\n            // decide which state to keep, seeing as how they are both equal and in open.\r\n            openList.keepOne(existingState, newState, SingleAgentAStar_Solver.equalStatesDiscriminator);\r\n        }\r\n\r\n        /**\r\n         * Trace back a plan from this state, return the plan after it was updates with the moves found by going back\r\n         * from this state.\r\n         * @param existingPlan an existing plan which we are continuing.\r\n         * @return the existingPlan after updating it with the plan that this state represents.\r\n         */\r\n        public SingleAgentPlan backTracePlan(SingleAgentPlan existingPlan) {\r\n            List<Move> moves = new ArrayList<>();\r\n            AStarState currentState = this;\r\n            while (currentState != null){\r\n                moves.add(currentState.move);\r\n                currentState = currentState.prev;\r\n            }\r\n            Collections.reverse(moves); //reorder moves because they were reversed\r\n\r\n            // patch move times in case we had moves that don't progress time, because they were after last constraint time\r\n            for (int i = 1; i < moves.size(); i++) {\r\n                Move prevMove = moves.get(i-1);\r\n                Move currMove = moves.get(i);\r\n                if (currMove.timeNow != prevMove.timeNow + 1){\r\n                    moves.set(i, new Move(currMove.agent, prevMove.timeNow + 1, currMove.prevLocation, currMove.currLocation));\r\n                }\r\n            }\r\n\r\n            //if there was an existing plan before solving, then we started from its last move, and don't want to duplicate it.\r\n            if(existingPlan.size() > 0) {moves.remove(0);}\r\n            existingPlan.addMoves(moves);\r\n            return existingPlan;\r\n        }\r\n\r\n\r\n        /**\r\n         * equality is determined by location (current), and time.\r\n         * @param o {@inheritDoc}\r\n         * @return {@inheritDoc}\r\n         */\r\n        @Override\r\n        public boolean equals(Object o) {\r\n            if (this == o) return true;\r\n            if (!(o instanceof AStarState that)) return false;\r\n\r\n            if (\r\n//                    (timeDimension || that.timeDimension) &&\r\n                            (move.timeNow != that.move.timeNow)) return false;\r\n            return move.currLocation.equals(that.move.currLocation);\r\n        }\r\n\r\n        @Override\r\n        public int hashCode() {\r\n            int result = move.currLocation.hashCode();\r\n//            if (timeDimension){\r\n                result = 31 * result + move.timeNow;\r\n//            }\r\n            return result;\r\n        }\r\n\r\n        @Override\r\n        public int compareTo(@NotNull AStarState o) {\r\n            return stateFComparator.compare(this, o);\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"AStarState{\" +\r\n                    \"serialID=\" + serialID +\r\n                    \", g=\" + g +\r\n                    \", h=\" + h +\r\n                    \", conflicts=\" + conflicts +\r\n                    \", plan=\\n\" + this.backTracePlan(new SingleAgentPlan(this.move.agent)).toString() +\r\n                    '}';\r\n        }\r\n\r\n    } ////////// end AStarState\r\n\r\n\r\n    /**\r\n     * For sorting the open list.\r\n     */\r\n    private static class TieBreakingForLessConflictsAndHigherG implements Comparator<AStarState>{\r\n\r\n        private static final Comparator<AStarState> fComparator = Comparator.comparing(AStarState::getF);\r\n\r\n        @Override\r\n        public int compare(AStarState o1, AStarState o2) {\r\n            if(Math.abs(o1.getF() - o2.getF()) < 0.1){ // floats are equal\r\n                // if f() value is equal, we consider the state with less conflicts to be better.\r\n                if(o1.conflicts == o2.conflicts){\r\n                    // if equal in conflicts, we break ties for higher g. Therefore, we want to return a negative\r\n                    // integer if o1.g is bigger than o2.g\r\n                    if (o2.g == o1.g){\r\n                        // If still equal, we tie break for smaller ID (older nodes) (arbitrary) to force a total ordering and remain deterministic\r\n                        return o1.serialID - o2.serialID;\r\n\r\n                    }\r\n                    else {\r\n                        return o2.g - o1.g; //higher g is better\r\n                    }\r\n                }\r\n                else{\r\n                    return o1.conflicts - o2.conflicts; // less conflicts is better\r\n                }\r\n            }\r\n            else {\r\n                return fComparator.compare(o1, o2);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * For deciding which state to keep between two equal states in open.\r\n     */\r\n    private static class TieBreakingForLowerGAndLessConflicts implements Comparator<AStarState>{\r\n\r\n        @Override\r\n        public int compare(AStarState o1, AStarState o2) {\r\n            // if f() is monotone non-decreasing, we should never actually find a new state with lower G than\r\n            // existing equal state in open.\r\n            // we break ties for lower g. Therefore, we want to return a positive integer if o1.g is bigger than o2.g.\r\n            // g should be equal in practice if G=state-time, and state equality is also defined by state-time.\r\n            if (o2.g == o1.g){\r\n                // if G() value is equal, we consider the state with less conflicts to be better.\r\n                if(o1.conflicts == o2.conflicts){\r\n                    // If still equal, we tie break for smaller ID (older nodes) (arbitrary) to remain deterministic\r\n                    return o1.serialID - o2.serialID;\r\n                }\r\n                else{\r\n                    return o1.conflicts - o2.conflicts; // less conflicts is better\r\n                }\r\n\r\n            }\r\n            else {\r\n                return o1.g - o2.g; //lower g is better\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/BasicMAPF/Solvers/AStar/SingleAgentAStar_Solver.java b/src/main/java/BasicMAPF/Solvers/AStar/SingleAgentAStar_Solver.java
--- a/src/main/java/BasicMAPF/Solvers/AStar/SingleAgentAStar_Solver.java	(revision b7dee42a7e06e50107bd2d08be8437bc03f0d8b2)
+++ b/src/main/java/BasicMAPF/Solvers/AStar/SingleAgentAStar_Solver.java	(date 1686648555020)
@@ -31,14 +31,15 @@
 
     public boolean agentsStayAtGoal;
 
-    private ConstraintSet constraints;
-    private AStarGAndH gAndH;
-    private final I_OpenList<AStarState> openList = new OpenListTree<>(stateFComparator);
-    private final Set<AStarState> closed = new HashSet<>();
-    private Agent agent;
-    private I_Map map;
-    private SingleAgentPlan existingPlan;
-    private Solution existingSolution;
+    protected ConstraintSet constraints;
+    protected AStarGAndH gAndH;
+    protected final I_OpenList<AStarState> openList = new OpenListTree<>(stateFComparator);
+    protected final Set<AStarState> closed = new HashSet<>();
+    protected Agent agent;
+
+    protected I_Map map;
+    protected SingleAgentPlan existingPlan;
+    protected Solution existingSolution;
     private I_ConflictAvoidanceTable conflictAvoidanceTable;
     public I_Coordinate sourceCoor;
     public I_Coordinate targetCoor;
@@ -46,13 +47,13 @@
     /**
      * Not real-world time. The problem's start time.
      */
-    private int problemStartTime;
-    private int expandedNodes;
+    protected int problemStartTime;
+    protected int expandedNodes;
     private int generatedNodes;
     /**
      * Maximum allowed f value ({@link SingleAgentPlan} cost). Will stop and return null if proved that it cannot be found.
      */
-    private float fBudget;
+    protected float fBudget;
 
     public SingleAgentAStar_Solver() {this(null);}
 
@@ -173,13 +174,11 @@
                     // update this.existingPlan which is contained in this.existingSolution
                     currentState.backTracePlan(this.existingPlan);
                     return this.existingSolution; // the goal is good, and we can return the plan.
-                }
-                else{ // we are rejected from the goal location at some point in the future.
-                    currentState.expand();
+                } else { // we are rejected from the goal location at some point in the future.
+                    expand(currentState);
                 }
-            }
-            else{ //expand
-                currentState.expand(); //doesn't generate closed or duplicate states
+            } else { //expand
+                expand(currentState); //doesn't generate closed or duplicate states
             }
         }
         return null; //no goal state found (problem unsolvable)
@@ -222,15 +221,63 @@
             }
 
         }
-
         // if none of the root nodes was valid, OPEN will be empty, and thus uninitialised.
         return !openList.isEmpty();
     }
 
-    private boolean isGoalState(AStarState state) {
+    protected void expand(@NotNull AStarState state) {
+        expandedNodes++;
+        // can move to neighboring locations or stay put
+        List<I_Location> neighborLocationsIncludingCurrent = new ArrayList<>(state.move.currLocation.outgoingEdges());
+        // no point to do stay moves or search the time dimension after the time of last constraint.
+        // this makes A* complete even when there are goal constraints (infinite constraints)
+        boolean afterLastConstraint = state.move.timeNow > constraints.getLastConstraintTime();
+        if (!afterLastConstraint &&
+                !state.move.currLocation.getType().equals(Enum_MapLocationType.NO_STOP)) { // can't stay on NO_STOP
+            neighborLocationsIncludingCurrent.add(state.move.currLocation);
+        }
+
+        for (I_Location destination : neighborLocationsIncludingCurrent) {
+            // give all moves after last constraint time the same time so that they're equal. patch the plan later to correct times
+            Move possibleMove = new Move(state.move.agent, !afterLastConstraint ? state.move.timeNow + 1 : state.move.timeNow,
+                    state.move.currLocation, destination);
+            if (possibleMove.prevLocation.equals(possibleMove.currLocation) && state.move.isStayAtSource) {
+                possibleMove.isStayAtSource = true;
+            }
+
+            // move not prohibited by existing constraint
+            if (constraints.accepts(possibleMove)) {
+                AStarState child = new AStarState(possibleMove, state,
+                        state.g + gAndH.cost(possibleMove),
+                        state.conflicts + numConflicts(possibleMove));
+
+                AStarState existingState;
+                if (closed.contains(child)) { // state visited already
+                    // TODO for inconsistent heuristics - if the new one has a lower f, remove the old one from closed
+                    // and add the new one to open
+                } else if (null != (existingState = openList.get(child))) { //an equal state is waiting in open
+                    //keep the one with min G
+                    state.keepTheStateWithMinG(child, existingState); //O(LOGn)
+                } else { // it's a new state
+                    openList.add(child);
+                }
+            }
+        }
+    }
+
+
+    protected boolean isGoalState(AStarState state) {
         return this.goalCondition.isAGoal(state);
     }
 
+    public int getGeneratedNodes() {
+        return this.generatedNodes;
+    }
+
+    public int getExpandedNodes() {
+        return this.expandedNodes;
+    }
+
     /*  = wind down =  */
 
     protected void writeMetricsToReport(Solution solution) {
@@ -259,7 +306,7 @@
         this.goalCondition = null;
     }
 
-    private int numConflicts(Move move){
+    protected int numConflicts(Move move){
         // TODO to support PIBT paths with tie breaking by num conflicts, may have to create duplicate nodes after
         //  reaching a goal, one as a last move and one as an intermediate move, because they would have a different number of conflicts.
         return conflictAvoidanceTable == null ? 0 : conflictAvoidanceTable.numConflicts(move, false);
@@ -276,8 +323,8 @@
         private final int serialID = SingleAgentAStar_Solver.this.generatedNodes++; // take and increment
         public final Move move;
         private final AStarState prev;
-        private final int g;
-        private final float h;
+        protected final int g;
+        protected final float h;
 //        /**
 //         * If true we search both the space and the time dimension.
 //         */
@@ -285,7 +332,7 @@
         /**
          * counts the number of conflicts generated by this node and all its ancestors.
          */
-        private final int conflicts;
+        protected int conflicts;
 
         public AStarState(Move move, AStarState prevState, int g, int conflicts
 //                , boolean timeDimension
@@ -301,6 +348,14 @@
             this.h = calcH();
         }
 
+        public AStarState() {
+
+            move = null;
+            prev = null;
+            g = 0;
+            h = 0;
+        }
+
 
         /*  = getters =  */
         public Move getMove() {
@@ -327,49 +382,7 @@
             return SingleAgentAStar_Solver.this.gAndH.getH(this);
         }
 
-        public void expand() {
-            expandedNodes++;
-            // can move to neighboring locations or stay put
-            List<I_Location> neighborLocationsIncludingCurrent = new ArrayList<>(this.move.currLocation.outgoingEdges());
-            // no point to do stay moves or search the time dimension after the time of last constraint.
-            // this makes A* complete even when there are goal constraints (infinite constraints)
-            boolean afterLastConstraint = this.move.timeNow > constraints.getLastConstraintTime();
-            if (!afterLastConstraint &&
-                    !this.move.currLocation.getType().equals(Enum_MapLocationType.NO_STOP)){ // can't stay on NO_STOP
-                neighborLocationsIncludingCurrent.add(this.move.currLocation);
-            }
-
-            for (I_Location destination: neighborLocationsIncludingCurrent){
-                // give all moves after last constraint time the same time so that they're equal. patch the plan later to correct times
-                Move possibleMove = new Move(this.move.agent, !afterLastConstraint ? this.move.timeNow + 1 : this.move.timeNow,
-                        this.move.currLocation, destination);
-                if (possibleMove.prevLocation.equals(possibleMove.currLocation) && this.move.isStayAtSource){
-                    possibleMove.isStayAtSource = true;
-                }
-
-                // move not prohibited by existing constraint
-                if(constraints.accepts(possibleMove)){
-                    AStarState child = new AStarState(possibleMove, this,
-                            this.g + SingleAgentAStar_Solver.this.gAndH.cost(possibleMove),
-                            conflicts + numConflicts(possibleMove));
-
-                    AStarState existingState;
-                    if(closed.contains(child)){ // state visited already
-                        // TODO for inconsistent heuristics - if the new one has a lower f, remove the old one from closed
-                        // and add the new one to open
-                    }
-                    else if(null != (existingState = openList.get(child)) ){ //an equal state is waiting in open
-                        //keep the one with min G
-                        keepTheStateWithMinG(child, existingState); //O(LOGn)
-                    }
-                    else{ // it's a new state
-                        openList.add(child);
-                    }
-                }
-            }
-        }
-
-        private void keepTheStateWithMinG(AStarState newState, AStarState existingState) {
+        protected void keepTheStateWithMinG(AStarState newState, AStarState existingState) {
             // decide which state to keep, seeing as how they are both equal and in open.
             openList.keepOne(existingState, newState, SingleAgentAStar_Solver.equalStatesDiscriminator);
         }
Index: src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/ConstraintSet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package BasicMAPF.Solvers.ConstraintsAndConflicts.Constraint;\r\n\r\nimport BasicMAPF.Instances.Agent;\r\nimport BasicMAPF.Instances.Maps.I_Location;\r\nimport BasicMAPF.Solvers.Move;\r\nimport BasicMAPF.Solvers.SingleAgentPlan;\r\nimport BasicMAPF.Solvers.Solution;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * A set of {@link Constraint}s.\r\n * Adding and removing constraints is O(1). Checking if the set {@link #rejects(Move)} or {@link #accepts(Move)} is O(n)\r\n * in the worst case. However, there will usually be very few unique constraints for every pair of [time,location], with\r\n * many unique pairs of [time,location]. Therefore, it is on average O(1).\r\n */\r\npublic class ConstraintSet{\r\n\r\n    /**\r\n     * Basically a dictionary from [time,location] to agents who can't go there at that time, and locations from which\r\n     * they can't go there at that time.\r\n     */\r\n    protected final Map<I_ConstraintGroupingKey, Set<Constraint>> constraints = new HashMap<>();\r\n\r\n    /**\r\n     * Goal constraints. Locations in this collection are reserved starting from the constraint's time, indefinitely.\r\n     */\r\n    protected final Map<I_Location, GoalConstraint> goalConstraints = new HashMap<>();\r\n\r\n    protected int lastConstraintTime = -1;\r\n\r\n    /**\r\n     * If set to true, agents who share the same goal may occupy their goal vertex at the same time.\r\n     */\r\n    public boolean sharedGoals;\r\n    /**\r\n     * If true, agents staying at their source (since the start) will not constrain agents with the same source\r\n     */\r\n    public boolean sharedSources;\r\n\r\n    public ConstraintSet() {\r\n        this(null, null);\r\n    }\r\n\r\n    public ConstraintSet(Boolean sharedGoals, Boolean sharedSources) {\r\n        this.sharedGoals = Objects.requireNonNullElse(sharedGoals, false);\r\n        this.sharedSources = Objects.requireNonNullElse(sharedSources, false);\r\n    }\r\n\r\n    public ConstraintSet(ConstraintSet toCopy){\r\n        if(toCopy == null) {throw new IllegalArgumentException();}\r\n        this.sharedGoals = toCopy.sharedGoals;\r\n        this.sharedSources = toCopy.sharedSources;\r\n        this.addAll(toCopy);\r\n        this.lastConstraintTime = toCopy.lastConstraintTime;\r\n    }\r\n\r\n    public ConstraintSet(Collection<? extends Constraint> seedConstraints) {\r\n        this();\r\n        if(seedConstraints == null) {throw new IllegalArgumentException();}\r\n        this.addAll(seedConstraints);\r\n    }\r\n\r\n    /*  = Set Interface =  */\r\n\r\n    //removed, because the size of constraints field isn't the number of constraints in the set. if we need this, add size field to class.\r\n//    public int size() {\r\n//        return constraints.size();\r\n//    }\r\n\r\n    public boolean isEmpty() {\r\n        return constraints.isEmpty();\r\n    }\r\n\r\n    /**\r\n     * @return the time of the last constraint. If it is a goal constraint (infinite), return the time when it starts\r\n     */\r\n    public int getLastConstraintTime(){\r\n        return this.lastConstraintTime;\r\n    }\r\n\r\n    public void add(Constraint constraint){\r\n        if(constraint instanceof  RangeConstraint){\r\n            // add an individual constraint for each of the times covered by the range constraint\r\n            RangeConstraint rangeConstraint = (RangeConstraint) constraint;\r\n\r\n            for (int time = rangeConstraint.lowerBound; time <= rangeConstraint.upperBound; time++) {\r\n                this.add(rangeConstraint.getConstraint(time));\r\n            }\r\n            this.lastConstraintTime = Math.max(this.lastConstraintTime, rangeConstraint.upperBound);\r\n        }\r\n        else if (constraint instanceof GoalConstraint){\r\n            // can only have existing goal constraint if this.sharedGoal == true\r\n            GoalConstraint existingGoalConstraintAtLocation = this.goalConstraints.get(constraint.location);\r\n            if (existingGoalConstraintAtLocation == null || existingGoalConstraintAtLocation.time > constraint.time){\r\n                this.goalConstraints.put(constraint.location, (GoalConstraint) constraint);\r\n            }\r\n            this.lastConstraintTime = Math.max(this.lastConstraintTime, constraint.time);\r\n        }\r\n        else{ // regular constraint\r\n            I_ConstraintGroupingKey dummy = createDummy(constraint);\r\n            this.constraints.computeIfAbsent(dummy, k -> new HashSet<>());\r\n            add(this.constraints.get(dummy), constraint);\r\n            this.lastConstraintTime = Math.max(this.lastConstraintTime, constraint.time);\r\n        }\r\n\r\n    }\r\n\r\n    protected void add(Set<Constraint> constraintSet, Constraint constraint){\r\n        constraintSet.add(constraint);\r\n    }\r\n\r\n    public void addAll(Collection<? extends Constraint> constraints) {\r\n        for (Constraint cons : constraints) {\r\n            this.add(cons);\r\n        }\r\n    }\r\n\r\n    public void addAll(ConstraintSet other) {\r\n        for (I_ConstraintGroupingKey cw : other.constraints.keySet()) {\r\n            for (Constraint cons : other.constraints.get(cw)) {\r\n                this.add(cons);\r\n            }\r\n        }\r\n        for (I_Location loc : other.goalConstraints.keySet()){\r\n            this.add(other.goalConstraints.get(loc));\r\n        }\r\n    }\r\n\r\n    public void remove(Constraint constraint){\r\n        if(constraint instanceof  RangeConstraint){\r\n            // there is a problem with removing range constraints, since they may overlap.\r\n            throw new UnsupportedOperationException();\r\n        }\r\n        else if (constraint instanceof  GoalConstraint){\r\n            while (this.goalConstraints.values().remove(constraint));\r\n        }\r\n        else { // regular constraint\r\n            I_ConstraintGroupingKey dummy = createDummy(constraint);\r\n\r\n            if (this.constraints.containsKey(dummy)) {\r\n                Set<Constraint> constraints = this.constraints.get(dummy);\r\n                constraints.remove(constraint);\r\n                if (constraints.isEmpty()) {\r\n                    // if we've emptied the constraints, there is no more reason to keep an entry.\r\n                    this.constraints.remove(dummy);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param constraints\r\n     * @return true if this caused the set to change.\r\n     */\r\n    public void removeAll(Collection<? extends Constraint> constraints) {\r\n        for (Constraint cons : constraints) {\r\n            this.remove(cons);\r\n        }\r\n    }\r\n\r\n    public void clear() {\r\n        this.constraints.clear();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param move\r\n     * @return the opposite of {@link #rejects(Move)}\r\n     */\r\n    public boolean accepts(Move move){\r\n        return !rejects(move);\r\n    }\r\n\r\n    /**\r\n     * Returns true iff any of the {@link Constraint}s that were {@link #add(Constraint) added} to this set conflict with\r\n     * the given {@link Move}.\r\n     * @param move a {@link Move} to check if it is rejected or not.\r\n     * @return true iff any of the {@link Constraint}s that were {@link #add(Constraint) added} to this set\r\n     *          conflict with the given {@link Move}.\r\n     */\r\n    public boolean rejects(Move move){\r\n        I_ConstraintGroupingKey dummy = createDummy(move);\r\n        boolean rejects = false;\r\n        if (constraints.containsKey(dummy)){\r\n            rejects = rejects(constraints.get(dummy), move);\r\n        }\r\n        if (!rejects && goalConstraints.containsKey(move.currLocation)){\r\n            rejects = sharedGoals ?  goalConstraints.get(move.currLocation).rejectsWithSharedGoals(move) : goalConstraints.get(move.currLocation).rejects(move);\r\n        }\r\n        return rejects;\r\n    }\r\n\r\n    protected boolean rejects(Set<Constraint> constraints, Move move){\r\n        for (Constraint constraint : constraints){\r\n            if(constraint.rejects(move))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Given a {@link Move} which an {@link Agent agent} makes to occupy a {@link I_Location location}\r\n     * indefinitely starting after move's time, checks if there is a {@link Constraint} that would reject it eventually.\r\n     *\r\n     * In other words, we simulate this set being given an infinite number of \"stay\" moves after the given move.\r\n     *\r\n     * This method can be expensive in large sets, as it traverses all of {@link #constraints}.\r\n     * @param finalMove a move to occupy a location indefinitely.\r\n     * @return the first time when a constraint would eventually reject a \"stay\" move at the given move's location; -1 if never rejected.\r\n     */\r\n    public int rejectsEventually(Move finalMove){\r\n        int firstRejectionTime = Integer.MAX_VALUE;\r\n        // TODO faster implementation. Probably with TreeSet.ceiling() and sorting keys by primary=location secondary=time\r\n        // traverses the entire data structure. expensive.\r\n        for (I_ConstraintGroupingKey cw : constraints.keySet()) {\r\n            // if found constraint for this location, sometime in the future. Should be rare.\r\n            if(cw.relevantInTheFuture(finalMove)){\r\n                for (Constraint constraint : constraints.get(cw)) {\r\n                    // make an artificial \"stay\" move for the relevant time.\r\n                    // In practice, this should happen very rarely, so not very expensive.\r\n                    int constraintTime = cw.getTime();\r\n                    if(constraint.rejects(new Move(finalMove.agent, constraintTime, finalMove.currLocation, finalMove.currLocation))\r\n                            && constraintTime < firstRejectionTime){\r\n                        firstRejectionTime = constraintTime;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // #goalConstraints is irrelevant, since if there are no shared goals, there won't be two agents trying to get\r\n        // to the same goal, and if there are shared goals then it's not a conflict\r\n\r\n        return firstRejectionTime == Integer.MAX_VALUE ? -1 : firstRejectionTime;\r\n    }\r\n\r\n    /**\r\n     * The opposite of {@link #rejectsEventually(Move)}.\r\n     * @param finalMove a move to occupy a location indefinitely.\r\n     * @return true if no constraint would eventually reject a \"stay\" move at the given move's location.\r\n     */\r\n    public boolean acceptsForever(Move finalMove){\r\n        return rejectsEventually(finalMove) == -1;\r\n    }\r\n\r\n    /**\r\n     * Returns true iff any of the {@link Constraint}s that were {@link #add(Constraint) added} to this set conflict with\r\n     * the given {@link Move}.\r\n     *\r\n     * Doesn't assume that the last move means stay at goal forever.\r\n     * @see #acceptsForever(Move)\r\n     * @param moves a {@link Collection} of {@link Move}s to check if the are ejected or not.\r\n     * @return true iff all of the given {@link Move}s conflict with any of the {@link Constraint}s that were\r\n     *          {@link #add(Constraint) added} to this set.\r\n     */\r\n    public boolean rejectsAll(Collection<? extends Move> moves){\r\n        boolean result = true;\r\n        for (Move move : moves) {\r\n            result &= this.rejects(move);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns true iff none of the {@link Constraint}s that were {@link #add(Constraint) added} to this set conflict with\r\n     * the given {@link Move}.\r\n     *\r\n     * Doesn't assume that the last move means stay at goal forever.\r\n     * @see #acceptsForever(Move)\r\n     * @param moves\r\n     * @return the opposite of {@link #rejectsAll(Collection)}.\r\n     */\r\n    public boolean acceptsAll(Collection<? extends Move> moves){\r\n        boolean result = true;\r\n        for (Move move : moves) {\r\n            result &= this.accepts(move);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Removes constraints for times that are not in the given range.\r\n     * @param minTime the minimum time (inclusive).\r\n     * @param maxTime the maximum time (exclusive).\r\n     */\r\n    public void trimToTimeRange(int minTime, int maxTime){\r\n        this.constraints.keySet().removeIf(cw -> ((TimeLocation)cw).time < minTime || ((TimeLocation)cw).time >= maxTime);\r\n    }\r\n\r\n    protected I_ConstraintGroupingKey createDummy(Constraint constraint){\r\n        return new TimeLocation(constraint);\r\n    }\r\n\r\n    protected I_ConstraintGroupingKey createDummy(Move move){\r\n        return new TimeLocation(move);\r\n    }\r\n\r\n\r\n    /**\r\n     * Find the last time when the agent is prevented from being at its goal.\r\n     *\r\n     * This method can be expensive in large sets, as it traverses all of {@link #constraints}.\r\n     * @param target the agent's target.\r\n     * @param agent the agent.\r\n     * @return the first time when a constraint would eventually reject a \"stay\" move at the given move's location; -1 if never rejected.\r\n     */\r\n    public int lastRejectAt(I_Location target, Agent agent) {\r\n        int lastRejectionTime = Integer.MIN_VALUE;\r\n        Move fakeFinalMove = new Move(agent, 1, target, target);\r\n        // traverses the entire data structure. expensive.\r\n        for (I_ConstraintGroupingKey cw :\r\n                constraints.keySet()) {\r\n            //found constraint for this location, sometime in the future. Should be rare.\r\n            if(cw.relevantInTheFuture(fakeFinalMove)){\r\n                for (Constraint constraint :\r\n                        constraints.get(cw)) {\r\n                    // make an artificial \"stay\" move for the relevant time.\r\n                    // In practice, this should happen very rarely, so not very expensive.\r\n                    int constraintTime = ((TimeLocation)cw).time;\r\n                    if(constraint.rejects(new Move(agent, constraintTime, target, target))\r\n                            && constraintTime > lastRejectionTime){\r\n                        lastRejectionTime = constraintTime;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return lastRejectionTime == Integer.MIN_VALUE ? -1 : lastRejectionTime;\r\n    }\r\n\r\n    /*  = translating moves and plans into constraints =*/\r\n\r\n//    public List<Constraint> vertexConstraintsForPlan(SingleAgentPlan planForAgent) {\r\n//        List<Constraint> constraints = new LinkedList<>();\r\n//        for (Move move :\r\n//                planForAgent) {\r\n//            constraints.add(vertexConstraintsForMove(move));\r\n//        }\r\n//        return constraints;\r\n//    }\r\n\r\n    public static Constraint vertexConstraintsForMove(Move move){\r\n        return new Constraint(null, move.timeNow, move.currLocation);\r\n    }\r\n\r\n    public static Constraint stayAtSourceConstraintsForMove(Move move){\r\n        return new StayAtSourceConstraint(move.timeNow, move.currLocation);\r\n    }\r\n\r\n//    public List<Constraint> swappingConstraintsForPlan(SingleAgentPlan planForAgent) {\r\n//        List<Constraint> constraints = new LinkedList<>();\r\n//        for (Move move :\r\n//                planForAgent) {\r\n//            constraints.add(swappingConstraintsForMove(move));\r\n//        }\r\n//        return constraints;\r\n//    }\r\n\r\n    public static Constraint swappingConstraintsForMove(Move move){\r\n        return new Constraint(null, move.timeNow,\r\n                /*the constraint is in opposite direction of the move*/ move.currLocation, move.prevLocation);\r\n    }\r\n\r\n    public static Constraint goalConstraintForMove(Move move){\r\n        return new GoalConstraint(move.timeNow, move.currLocation);\r\n    }\r\n\r\n    /**\r\n     * Creates constraints to protect a {@link SingleAgentPlan plan}.\r\n     * @param singleAgentPlan a plan to get constraints for.\r\n     * @return all constraints to protect the plan.\r\n     */\r\n    public List<Constraint> allConstraintsForPlan(SingleAgentPlan singleAgentPlan) {\r\n        List<Constraint> constraints = new LinkedList<>();\r\n        boolean stayingAtSourceSinceStart = true;\r\n        // protect the agent's plan\r\n        for (int t = singleAgentPlan.getFirstMoveTime(); t <= singleAgentPlan.getEndTime(); t++) {\r\n            Move move = singleAgentPlan.moveAt(t);\r\n            boolean isStayMove = move.prevLocation.equals(move.currLocation);\r\n            stayingAtSourceSinceStart &= isStayMove;\r\n\r\n            if (!isStayMove){\r\n                constraints.add(swappingConstraintsForMove(move));\r\n            }\r\n            if (move.timeNow != singleAgentPlan.getEndTime()){\r\n                if (sharedSources && stayingAtSourceSinceStart){\r\n                    // with shared sources, replace the vertex constraints for stay at source constraints when appropriate\r\n                    constraints.add(stayAtSourceConstraintsForMove(move));\r\n                }\r\n                else {\r\n                    constraints.add(vertexConstraintsForMove(move));\r\n                }\r\n            }\r\n            else{ // for the last move don't save a vertex constraint, instead save a goal constraint\r\n                constraints.add(goalConstraintForMove(singleAgentPlan.moveAt(singleAgentPlan.getEndTime())));\r\n            }\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    /**\r\n     * Creates constraints to protect a {@link Solution}.\r\n     @param solution to get constraints for.\r\n     @return all constraints to protect the solution.\r\n     */\r\n    public List<Constraint> allConstraintsForSolution(Solution solution) {\r\n        List<Constraint> constraints = new LinkedList<>();\r\n        for (SingleAgentPlan p :\r\n                solution) {\r\n            constraints.addAll(this.allConstraintsForPlan(p));\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    /* = from Object = */\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (!(o instanceof ConstraintSet)) return false;\r\n\r\n        ConstraintSet that = (ConstraintSet) o;\r\n\r\n        return constraints.equals(that.constraints);\r\n\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return constraints.hashCode();\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/ConstraintSet.java b/src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/ConstraintSet.java
--- a/src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/ConstraintSet.java	(revision b7dee42a7e06e50107bd2d08be8437bc03f0d8b2)
+++ b/src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/ConstraintSet.java	(date 1685967547196)
@@ -46,6 +46,9 @@
         this.sharedGoals = Objects.requireNonNullElse(sharedGoals, false);
         this.sharedSources = Objects.requireNonNullElse(sharedSources, false);
     }
+    public Set<I_ConstraintGroupingKey> getKeySet(){
+        return constraints.keySet();
+    }
 
     public ConstraintSet(ConstraintSet toCopy){
         if(toCopy == null) {throw new IllegalArgumentException();}
Index: src/test/java/BasicMAPF/Solvers/AStar/SingleAgentAStar_SolverTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package BasicMAPF.Solvers.AStar;\r\n\r\nimport BasicMAPF.Instances.Maps.Coordinates.Coordinate_2D;\r\nimport BasicMAPF.Solvers.AStar.CostsAndHeuristics.AStarGAndH;\r\nimport BasicMAPF.Solvers.AStar.CostsAndHeuristics.DistanceTableAStarHeuristic;\r\nimport BasicMAPF.Solvers.AStar.CostsAndHeuristics.UnitCostsAndManhattanDistance;\r\nimport BasicMAPF.Solvers.AStar.GoalConditions.SingleTargetCoordinateGoalCondition;\r\nimport BasicMAPF.Solvers.AStar.GoalConditions.VisitedAGoalAtSomePointInPlanGoalCondition;\r\nimport Environment.IO_Package.IO_Manager;\r\nimport BasicMAPF.Instances.Agent;\r\nimport BasicMAPF.Instances.InstanceBuilders.InstanceBuilder_BGU;\r\nimport BasicMAPF.Instances.InstanceManager;\r\nimport BasicMAPF.Instances.InstanceProperties;\r\nimport BasicMAPF.Instances.MAPF_Instance;\r\nimport BasicMAPF.Instances.Maps.*;\r\nimport BasicMAPF.Solvers.*;\r\nimport BasicMAPF.Solvers.ConstraintsAndConflicts.Constraint.Constraint;\r\nimport BasicMAPF.Solvers.ConstraintsAndConflicts.Constraint.ConstraintSet;\r\nimport Environment.Metrics.InstanceReport;\r\nimport Environment.Metrics.S_Metrics;\r\nimport org.jetbrains.annotations.NotNull;\r\nimport org.junit.jupiter.api.AfterEach;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport java.util.*;\r\n\r\nimport static BasicMAPF.TestConstants.Coordiantes.*;\r\nimport static BasicMAPF.TestConstants.Maps.*;\r\nimport static BasicMAPF.TestConstants.Agents.*;\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\nclass SingleAgentAStar_SolverTest {\r\n\r\n    private I_Location location12Circle = mapCircle.getMapLocation(coor12);\r\n    private I_Location location13Circle = mapCircle.getMapLocation(coor13);\r\n    private I_Location location14Circle = mapCircle.getMapLocation(coor14);\r\n    private I_Location location22Circle = mapCircle.getMapLocation(coor22);\r\n    private I_Location location24Circle = mapCircle.getMapLocation(coor24);\r\n    private I_Location location32Circle = mapCircle.getMapLocation(coor32);\r\n    private I_Location location33Circle = mapCircle.getMapLocation(coor33);\r\n    private I_Location location34Circle = mapCircle.getMapLocation(coor34);\r\n\r\n    private I_Location location11 = mapCircle.getMapLocation(coor11);\r\n    private I_Location location43 = mapCircle.getMapLocation(coor43);\r\n    private I_Location location53 = mapCircle.getMapLocation(coor53);\r\n    private I_Location location05 = mapCircle.getMapLocation(coor05);\r\n\r\n    private I_Location location04 = mapCircle.getMapLocation(coor04);\r\n    private I_Location location00 = mapCircle.getMapLocation(coor00);\r\n\r\n    InstanceManager im = new InstanceManager(IO_Manager.buildPath( new String[]{   IO_Manager.testResources_Directory,\"Instances\"}),\r\n            new InstanceBuilder_BGU(), new InstanceProperties(new MapDimensions(new int[]{6,6}),0f,new int[]{1}));\r\n\r\n    private MAPF_Instance instanceEmpty1 = new MAPF_Instance(\"instanceEmpty\", mapEmpty, new Agent[]{agent53to05});\r\n    private MAPF_Instance instanceEmpty2 = new MAPF_Instance(\"instanceEmpty\", mapEmpty, new Agent[]{agent43to11});\r\n    private MAPF_Instance instance1stepSolution = im.getNextInstance();\r\n    private MAPF_Instance instanceCircle1 = new MAPF_Instance(\"instanceCircle1\", mapCircle, new Agent[]{agent33to12});\r\n    private MAPF_Instance instanceCircle2 = new MAPF_Instance(\"instanceCircle1\", mapCircle, new Agent[]{agent12to33});\r\n    private MAPF_Instance instanceUnsolvable = new MAPF_Instance(\"instanceUnsolvable\", mapWithPocket, new Agent[]{agent04to00});\r\n    private MAPF_Instance instanceMaze1 = new MAPF_Instance(\"instanceMaze\", mapSmallMaze, new Agent[]{agent04to40});\r\n    private MAPF_Instance instanceMaze2 = new MAPF_Instance(\"instanceMaze\", mapSmallMaze, new Agent[]{agent00to55});\r\n    private MAPF_Instance instanceMaze3 = new MAPF_Instance(\"instanceMaze\", mapSmallMaze, new Agent[]{agent43to53});\r\n    private MAPF_Instance instanceMaze4 = new MAPF_Instance(\"instanceMaze\", mapSmallMaze, new Agent[]{agent53to15});\r\n\r\n    I_Solver aStar = new SingleAgentAStar_Solver();\r\n\r\n    InstanceReport instanceReport;\r\n\r\n    @BeforeEach\r\n    void setUp() {\r\n        instanceReport = S_Metrics.newInstanceReport();\r\n    }\r\n\r\n    @AfterEach\r\n    void tearDown() {\r\n        S_Metrics.removeReport(instanceReport);\r\n    }\r\n\r\n\r\n    @Test\r\n    void oneMoveSolution() {\r\n        MAPF_Instance testInstance = instance1stepSolution;\r\n        Solution s = aStar.solve(testInstance, new RunParameters());\r\n\r\n        Map<Agent, SingleAgentPlan> plans = new HashMap<>();\r\n        SingleAgentPlan plan = new SingleAgentPlan(testInstance.agents.get(0));\r\n        I_Location location = testInstance.map.getMapLocation(new Coordinate_2D(4,5));\r\n        plan.addMove(new Move(testInstance.agents.get(0), 1, location, location));\r\n        plans.put(testInstance.agents.get(0), plan);\r\n        Solution expected = new Solution(plans);\r\n\r\n        assertEquals(s, expected);\r\n    }\r\n\r\n    @Test\r\n    void circleOptimality1(){\r\n        MAPF_Instance testInstance = instanceCircle1;\r\n        Agent agent = testInstance.agents.get(0);\r\n\r\n        Solution solved = aStar.solve(testInstance, new RunParameters());\r\n\r\n        SingleAgentPlan plan = new SingleAgentPlan(agent);\r\n        plan.addMove(new Move(agent, 1, location33Circle, location32Circle));\r\n        plan.addMove(new Move(agent, 2, location32Circle, location22Circle));\r\n        plan.addMove(new Move(agent, 3, location22Circle, location12Circle));\r\n        Solution expected = new Solution();\r\n        expected.putPlan(plan);\r\n\r\n        assertEquals(3, solved.getPlanFor(agent).size());\r\n        assertEquals(expected, solved);\r\n\r\n    }\r\n\r\n    @Test\r\n    void circleOptimalityWaitingBecauseOfConstraint1(){\r\n        MAPF_Instance testInstance = instanceCircle1;\r\n        Agent agent = testInstance.agents.get(0);\r\n\r\n        //constraint\r\n        Constraint vertexConstraint = new Constraint(null, 1, null, location32Circle);\r\n        ConstraintSet constraints = new ConstraintSet();\r\n        constraints.add(vertexConstraint);\r\n        RunParameters parameters = new RunParameters(constraints);\r\n\r\n        Solution solved = aStar.solve(testInstance, parameters);\r\n\r\n        SingleAgentPlan plan = new SingleAgentPlan(agent);\r\n        plan.addMove(new Move(agent, 1, location33Circle, location33Circle));\r\n        plan.addMove(new Move(agent, 2, location33Circle, location32Circle));\r\n        plan.addMove(new Move(agent, 3, location32Circle, location22Circle));\r\n        plan.addMove(new Move(agent, 4, location22Circle, location12Circle));\r\n        Solution expected = new Solution();\r\n        expected.putPlan(plan);\r\n\r\n        assertEquals(4, solved.getPlanFor(agent).size());\r\n        assertEquals(expected, solved);\r\n\r\n    }\r\n\r\n    @Test\r\n    void circleOptimalityWaitingBecauseOfConstraint2(){\r\n        MAPF_Instance testInstance = instanceCircle1;\r\n        Agent agent = testInstance.agents.get(0);\r\n\r\n        //constraint\r\n        Constraint vertexConstraint = new Constraint(agent, 1, null, location32Circle);\r\n        ConstraintSet constraints = new ConstraintSet();\r\n        constraints.add(vertexConstraint);\r\n        RunParameters parameters = new RunParameters(constraints);\r\n\r\n        Solution solved = aStar.solve(testInstance, parameters);\r\n\r\n        SingleAgentPlan plan = new SingleAgentPlan(agent);\r\n        plan.addMove(new Move(agent, 1, location33Circle, location33Circle));\r\n        plan.addMove(new Move(agent, 2, location33Circle, location32Circle));\r\n        plan.addMove(new Move(agent, 3, location32Circle, location22Circle));\r\n        plan.addMove(new Move(agent, 4, location22Circle, location12Circle));\r\n        Solution expected = new Solution();\r\n        expected.putPlan(plan);\r\n\r\n        assertEquals(4, solved.getPlanFor(agent).size());\r\n        assertEquals(expected, solved);\r\n    }\r\n\r\n    @Test\r\n    void circleOptimalityWaitingBecauseOfConstraint3(){\r\n        MAPF_Instance testInstance = instanceCircle1;\r\n        Agent agent = testInstance.agents.get(0);\r\n\r\n        //constraint\r\n        Constraint swappingConstraint = new Constraint(agent, 1, location33Circle, location32Circle);\r\n        ConstraintSet constraints = new ConstraintSet();\r\n        constraints.add(swappingConstraint);\r\n        RunParameters parameters = new RunParameters(constraints);\r\n\r\n        Solution solved = aStar.solve(testInstance, parameters);\r\n\r\n        SingleAgentPlan plan = new SingleAgentPlan(agent);\r\n        plan.addMove(new Move(agent, 1, location33Circle, location33Circle));\r\n        plan.addMove(new Move(agent, 2, location33Circle, location32Circle));\r\n        plan.addMove(new Move(agent, 3, location32Circle, location22Circle));\r\n        plan.addMove(new Move(agent, 4, location22Circle, location12Circle));\r\n        Solution expected = new Solution();\r\n        expected.putPlan(plan);\r\n\r\n        assertEquals(4, solved.getPlanFor(agent).size());\r\n        assertEquals(expected, solved);\r\n    }\r\n\r\n    @Test\r\n    void circleOptimalityOtherDirectionBecauseOfConstraints(){\r\n        MAPF_Instance testInstance = instanceCircle1;\r\n        Agent agent = testInstance.agents.get(0);\r\n\r\n        //constraint\r\n        Constraint swappingConstraint1 = new Constraint(null, 1, location33Circle, location32Circle);\r\n        Constraint swappingConstraint2 = new Constraint(null, 2, location33Circle, location32Circle);\r\n        Constraint swappingConstraint3 = new Constraint(null, 3, location33Circle, location32Circle);\r\n        ConstraintSet constraints = new ConstraintSet();\r\n        constraints.add(swappingConstraint1);\r\n        constraints.add(swappingConstraint2);\r\n        constraints.add(swappingConstraint3);\r\n        RunParameters parameters = new RunParameters(constraints);\r\n\r\n        Solution solved = aStar.solve(testInstance, parameters);\r\n\r\n        SingleAgentPlan plan = new SingleAgentPlan(agent);\r\n        plan.addMove(new Move(agent, 1, location33Circle, location34Circle));\r\n        plan.addMove(new Move(agent, 2, location34Circle, location24Circle));\r\n        plan.addMove(new Move(agent, 3, location24Circle, location14Circle));\r\n        plan.addMove(new Move(agent, 4, location14Circle, location13Circle));\r\n        plan.addMove(new Move(agent, 5, location13Circle, location12Circle));\r\n        Solution expected = new Solution();\r\n        expected.putPlan(plan);\r\n\r\n        assertEquals(5, solved.getPlanFor(agent).size());\r\n        assertEquals(expected, solved);\r\n\r\n    }\r\n\r\n    @Test\r\n    void circleOptimalityNorthwestToSoutheast(){\r\n        MAPF_Instance testInstance = instanceCircle2;\r\n        Agent agent = testInstance.agents.get(0);\r\n\r\n        Solution solved = aStar.solve(testInstance, new RunParameters());\r\n\r\n        SingleAgentPlan plan = new SingleAgentPlan(agent);\r\n        plan.addMove(new Move(agent, 1, location12Circle, location22Circle));\r\n        plan.addMove(new Move(agent, 2, location22Circle, location32Circle));\r\n        plan.addMove(new Move(agent, 3, location32Circle, location33Circle));\r\n        Solution expected = new Solution();\r\n        expected.putPlan(plan);\r\n\r\n        assertEquals(3, solved.getPlanFor(agent).size());\r\n        assertEquals(expected, solved);\r\n    }\r\n\r\n    @Test\r\n    void emptyOptimality(){\r\n        MAPF_Instance testInstance1 = instanceEmpty1;\r\n        Agent agent1 = testInstance1.agents.get(0);\r\n\r\n        MAPF_Instance testInstance2 = instanceEmpty2;\r\n        Agent agent2 = testInstance2.agents.get(0);\r\n\r\n        Solution solved1 = aStar.solve(testInstance1, new RunParameters());\r\n        Solution solved2 = aStar.solve(testInstance2, new RunParameters());\r\n\r\n        assertEquals(7, solved1.getPlanFor(agent1).size());\r\n        assertEquals(5, solved2.getPlanFor(agent2).size());\r\n    }\r\n\r\n    @Test\r\n    void unsolvableShouldTimeout(){\r\n        MAPF_Instance testInstance = instanceUnsolvable;\r\n\r\n        // three second timeout\r\n        RunParameters runParameters = new RunParameters(1000*3);\r\n        Solution solved = aStar.solve(testInstance, runParameters);\r\n\r\n        assertNull(solved);\r\n    }\r\n\r\n    @Test\r\n    void accountsForConstraintAfterReachingGoal() {\r\n        MAPF_Instance testInstance = instanceEmpty1;\r\n        Agent agent = testInstance.agents.get(0);\r\n        Constraint constraintAtTimeAfterReachingGoal = new Constraint(agent,9, null, instanceEmpty1.map.getMapLocation(coor05));\r\n        ConstraintSet constraints = new ConstraintSet();\r\n        constraints.add(constraintAtTimeAfterReachingGoal);\r\n        RunParameters runParameters = new RunParameters(constraints);\r\n\r\n        Solution solved1 = aStar.solve(testInstance, runParameters);\r\n\r\n        //was made longer because it has to come back to goal after avoiding the constraint\r\n        assertEquals(10, solved1.getPlanFor(agent).size());\r\n    }\r\n\r\n    @Test\r\n    void accountsForConstraintAfterReachingGoal2() {\r\n        // now with an expected plan\r\n\r\n        MAPF_Instance testInstance = instanceCircle2;\r\n        Agent agent = testInstance.agents.get(0);\r\n\r\n        Constraint constraintAtTimeAfterReachingGoal1 = new Constraint(agent,5, null, location33Circle);\r\n        ConstraintSet constraints = new ConstraintSet();\r\n        constraints.add(constraintAtTimeAfterReachingGoal1);\r\n        RunParameters runParameters = new RunParameters(constraints);\r\n\r\n        Solution solved = aStar.solve(testInstance, runParameters);\r\n\r\n        SingleAgentPlan plan1 = new SingleAgentPlan(agent);\r\n        plan1.addMove(new Move(agent, 1, location12Circle, location22Circle));\r\n        plan1.addMove(new Move(agent, 2, location22Circle, location32Circle));\r\n        plan1.addMove(new Move(agent, 3, location32Circle, location33Circle));\r\n        plan1.addMove(new Move(agent, 4, location33Circle, location33Circle));\r\n        plan1.addMove(new Move(agent, 5, location33Circle, location32Circle));\r\n        plan1.addMove(new Move(agent, 6, location32Circle, location33Circle));\r\n        Solution expected1 = new Solution();\r\n        expected1.putPlan(plan1);\r\n\r\n        SingleAgentPlan plan2 = new SingleAgentPlan(agent);\r\n        plan2.addMove(new Move(agent, 1, location12Circle, location22Circle));\r\n        plan2.addMove(new Move(agent, 2, location22Circle, location32Circle));\r\n        plan2.addMove(new Move(agent, 3, location32Circle, location33Circle));\r\n        plan2.addMove(new Move(agent, 4, location33Circle, location33Circle));\r\n        plan2.addMove(new Move(agent, 5, location33Circle, location34Circle));\r\n        plan2.addMove(new Move(agent, 6, location34Circle, location33Circle));\r\n        Solution expected2 = new Solution();\r\n        expected2.putPlan(plan2);\r\n\r\n        assertEquals(6, solved.getPlanFor(agent).size());\r\n        assertTrue(expected1.equals(solved) || expected2.equals(solved));\r\n    }\r\n\r\n    @Test\r\n    void accountsForConstraintInFarFutureAfterReachingGoal() {\r\n        MAPF_Instance testInstance = instanceEmpty1;\r\n        Agent agent = testInstance.agents.get(0);\r\n        Constraint constraintAtTimeAfterReachingGoal = new Constraint(agent,9, null, instanceEmpty1.map.getMapLocation(coor05));\r\n        Constraint constraintAtTimeAfterReachingGoal2 = new Constraint(agent,90, null, instanceEmpty1.map.getMapLocation(coor05));\r\n        Constraint constraintAtTimeAfterReachingGoal3 = new Constraint(agent,200, null, instanceEmpty1.map.getMapLocation(coor05));\r\n        ConstraintSet constraints = new ConstraintSet();\r\n        constraints.add(constraintAtTimeAfterReachingGoal);\r\n        constraints.add(constraintAtTimeAfterReachingGoal2);\r\n        constraints.add(constraintAtTimeAfterReachingGoal3);\r\n        for (int t = 0; t < 200 /*agents*/ * 200 /*timesteps* * 2 /*constraints*/; t++) {\r\n            constraints.add(new Constraint(agent,t, null, instanceEmpty1.map.getMapLocation(coor15)));\r\n        }\r\n        RunParameters runParameters = new RunParameters(constraints);\r\n\r\n        Solution solved1 = aStar.solve(testInstance, runParameters);\r\n\r\n        //was made longer because it has to come back to goal after avoiding the constraint\r\n        assertEquals(201, solved1.getPlanFor(agent).size());\r\n    }\r\n\r\n    @Test\r\n    void accountsForMultipleConstraintsAfterReachingGoal() {\r\n        MAPF_Instance testInstance = instanceEmpty1;\r\n        Agent agent = testInstance.agents.get(0);\r\n        Constraint constraintAtTimeAfterReachingGoal1 = new Constraint(agent,9, null, instanceEmpty1.map.getMapLocation(coor05));\r\n        Constraint constraintAtTimeAfterReachingGoal2 = new Constraint(agent,13, null, instanceEmpty1.map.getMapLocation(coor05));\r\n        Constraint constraintAtTimeAfterReachingGoal3 = new Constraint(agent,14, null, instanceEmpty1.map.getMapLocation(coor05));\r\n        ConstraintSet constraints = new ConstraintSet();\r\n        constraints.add(constraintAtTimeAfterReachingGoal1);\r\n        constraints.add(constraintAtTimeAfterReachingGoal2);\r\n        constraints.add(constraintAtTimeAfterReachingGoal3);\r\n        RunParameters runParameters = new RunParameters(constraints);\r\n\r\n        Solution solved1 = aStar.solve(testInstance, runParameters);\r\n\r\n        //was made longer because it has to come back to goal after avoiding the constraint\r\n        assertEquals(15, solved1.getPlanFor(agent).size());\r\n    }\r\n\r\n    @Test\r\n    void continuingFromExistingPlan() {\r\n        // modified from circleOptimality1()\r\n\r\n        MAPF_Instance testInstance = instanceCircle1;\r\n        Agent agent = testInstance.agents.get(0);\r\n\r\n        SingleAgentPlan existingPlan = new SingleAgentPlan(agent);\r\n        existingPlan.addMove(new Move(agent, 1, location33Circle, location34Circle));\r\n        existingPlan.addMove(new Move(agent, 2, location34Circle, location24Circle));\r\n        Solution existingSolution = new Solution();\r\n        existingSolution.putPlan(existingPlan);\r\n\r\n        // give the solver a plan to continue from\r\n        Solution solved = aStar.solve(testInstance, new RunParameters(existingSolution));\r\n\r\n        SingleAgentPlan plan = new SingleAgentPlan(agent);\r\n        plan.addMove(new Move(agent, 1, location33Circle, location34Circle));\r\n        plan.addMove(new Move(agent, 2, location34Circle, location24Circle));\r\n        plan.addMove(new Move(agent, 3, location24Circle, location14Circle));\r\n        plan.addMove(new Move(agent, 4, location14Circle, location13Circle));\r\n        plan.addMove(new Move(agent, 5, location13Circle, location12Circle));\r\n        Solution expected = new Solution();\r\n        expected.putPlan(plan);\r\n\r\n        assertEquals(5, solved.getPlanFor(agent).size());\r\n        assertEquals(expected, solved);\r\n    }\r\n\r\n    @Test\r\n    void findsPIBTStylePlanUnderConstraintsUsingPIBTStyleGoalCondition() {\r\n        MAPF_Instance testInstance = instanceEmpty1;\r\n        Agent agent = testInstance.agents.get(0);\r\n        Constraint constraintAtTimeAfterReachingGoal1 = new Constraint(agent,9, null, instanceEmpty1.map.getMapLocation(coor05));\r\n        Constraint constraintAtTimeAfterReachingGoal2 = new Constraint(agent,13, null, instanceEmpty1.map.getMapLocation(coor05));\r\n        Constraint constraintAtTimeAfterReachingGoal3 = new Constraint(agent,14, null, instanceEmpty1.map.getMapLocation(coor05));\r\n        ConstraintSet constraints = new ConstraintSet();\r\n        constraints.add(constraintAtTimeAfterReachingGoal1);\r\n        constraints.add(constraintAtTimeAfterReachingGoal2);\r\n        constraints.add(constraintAtTimeAfterReachingGoal3);\r\n\r\n        RunParameters_SAAStar runParameters = new RunParameters_SAAStar(new RunParameters(constraints, new InstanceReport()));\r\n        runParameters.goalCondition = new VisitedAGoalAtSomePointInPlanGoalCondition(new SingleTargetCoordinateGoalCondition(agent.target));\r\n\r\n        Solution solved1 = aStar.solve(testInstance, runParameters);\r\n        System.out.println(solved1.getPlanFor(agent));\r\n\r\n        // has to visit goal at some point, and then can finish the plan anywhere else. So plan length is Manhattan Distance + 1\r\n        assertEquals(8, solved1.getPlanFor(agent).size());\r\n    }\r\n\r\n    @Test\r\n    void findsPIBTStylePlanUnderConstraintsAlsoAroundGoalUsingPIBTStyleGoalCondition() {\r\n        MAPF_Instance testInstance = instanceEmpty1;\r\n        Agent agent = testInstance.agents.get(0);\r\n        Constraint constraintAtTimeAfterReachingGoal1 = new Constraint(agent,9, null, instanceEmpty1.map.getMapLocation(coor05));\r\n        Constraint constraintAtTimeAfterReachingGoalAroundGoal1 = new Constraint(agent,14, null, instanceEmpty1.map.getMapLocation(coor15));\r\n        Constraint constraintAtTimeAfterReachingGoalAroundGoal2 = new Constraint(agent,14, null, instanceEmpty1.map.getMapLocation(coor04));\r\n        Constraint constraintAtTimeAfterReachingGoal2 = new Constraint(agent,13, null, instanceEmpty1.map.getMapLocation(coor05));\r\n        Constraint constraintAtTimeAfterReachingGoal3 = new Constraint(agent,14, null, instanceEmpty1.map.getMapLocation(coor05));\r\n        ConstraintSet constraints = new ConstraintSet();\r\n        constraints.add(constraintAtTimeAfterReachingGoal1);\r\n        constraints.add(constraintAtTimeAfterReachingGoal2);\r\n        constraints.add(constraintAtTimeAfterReachingGoal3);\r\n        constraints.add(constraintAtTimeAfterReachingGoalAroundGoal1);\r\n        constraints.add(constraintAtTimeAfterReachingGoalAroundGoal2);\r\n\r\n        RunParameters_SAAStar runParameters = new RunParameters_SAAStar(new RunParameters(constraints, new InstanceReport()));\r\n        runParameters.goalCondition = new VisitedAGoalAtSomePointInPlanGoalCondition(new SingleTargetCoordinateGoalCondition(agent.target));\r\n\r\n        Solution solved1 = aStar.solve(testInstance, runParameters);\r\n        System.out.println(solved1.getPlanFor(agent));\r\n\r\n        // has to visit goal at some point, and then can finish the plan anywhere else,\r\n        // but the surrounding locations also have constraints in the future, so has to take 2 steps\r\n        assertEquals(9, solved1.getPlanFor(agent).size());\r\n    }\r\n\r\n    private class UnitCostAndNoHeuristic implements AStarGAndH {\r\n        @Override\r\n        public float getH(SingleAgentAStar_Solver.AStarState state) {\r\n            return 0;\r\n        }\r\n\r\n        @Override\r\n        public int cost(Move move) {\r\n            return AStarGAndH.super.cost(move);\r\n        }\r\n\r\n        @Override\r\n        public boolean isConsistent() {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"All edges = 1\";\r\n        }\r\n    }\r\n\r\n    private final AStarGAndH unitCostAndNoHeuristic = new UnitCostAndNoHeuristic();\r\n\r\n    private static List<I_Location> planLocations(SingleAgentPlan planFromAStar) {\r\n        List<I_Location> aStarPlanLocations = new ArrayList<>();\r\n        for (Move move :\r\n                planFromAStar) {\r\n            if (move.timeNow == 1) {\r\n                aStarPlanLocations.add(move.prevLocation);\r\n            }\r\n            aStarPlanLocations.add(move.currLocation);\r\n        }\r\n        return aStarPlanLocations;\r\n    }\r\n\r\n    @Test\r\n    void optimalVsUCS1(){\r\n        MAPF_Instance testInstance = instanceMaze1;\r\n        Agent agent = testInstance.agents.get(0);\r\n\r\n        compareAStarAndUCS(aStar, instanceReport, agent, testInstance, unitCostAndNoHeuristic);\r\n    }\r\n\r\n    @Test\r\n    void optimalVsUCS2(){\r\n        MAPF_Instance testInstance = instanceMaze2;\r\n        Agent agent = testInstance.agents.get(0);\r\n\r\n        compareAStarAndUCS(aStar, instanceReport, agent, testInstance, unitCostAndNoHeuristic);\r\n    }\r\n    @Test\r\n    void optimalVsUCS3(){\r\n        MAPF_Instance testInstance = instanceMaze3;\r\n        Agent agent = testInstance.agents.get(0);\r\n\r\n        compareAStarAndUCS(aStar, instanceReport, agent, testInstance, unitCostAndNoHeuristic);\r\n    }\r\n    @Test\r\n    void optimalVsUCS4(){\r\n        MAPF_Instance testInstance = instanceMaze4;\r\n        Agent agent = testInstance.agents.get(0);\r\n\r\n        compareAStarAndUCS(aStar, instanceReport, agent, testInstance, unitCostAndNoHeuristic);\r\n    }\r\n    @Test\r\n    void optimalVsUCSDynamic(){\r\n        Map<I_ExplicitMap, String> maps = singleStronglyConnectedComponentMapsWithNames;\r\n        for (I_ExplicitMap testMap :\r\n                maps.keySet()) {\r\n            for (I_Location source :\r\n                    testMap.getAllLocations()) {\r\n                for (I_Location target :\r\n                        testMap.getAllLocations()) {\r\n                    if ( ! source.equals(target)){\r\n                        Agent agent = new Agent(0, source.getCoordinate(), target.getCoordinate());\r\n                        MAPF_Instance testInstance = new MAPF_Instance(\r\n                                maps.get(testMap) + \" \" + agent, testMap, new Agent[]{agent});\r\n                        compareAStarAndUCS(aStar, new InstanceReport(),\r\n                                agent, testInstance, unitCostAndNoHeuristic);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    @Test\r\n    void optimalVsUCSDynamicWithDistanceTableHeuristic(){\r\n        Map<I_ExplicitMap, String> maps = singleStronglyConnectedComponentMapsWithNames;\r\n        for (I_ExplicitMap testMap :\r\n                maps.keySet()) {\r\n            for (I_Location source :\r\n                    testMap.getAllLocations()) {\r\n                for (I_Location target :\r\n                        testMap.getAllLocations()) {\r\n                    if ( ! source.equals(target)){\r\n                        Agent agent = new Agent(0, source.getCoordinate(), target.getCoordinate());\r\n                        MAPF_Instance testInstance = new MAPF_Instance(\r\n                                maps.get(testMap) + \" \" + agent, testMap, new Agent[]{agent});\r\n                        DistanceTableAStarHeuristic distanceTableAStarHeuristic = new DistanceTableAStarHeuristic(testInstance.agents, testInstance.map);\r\n                        compareAStarAndUCS(aStar, new InstanceReport(),\r\n                                agent, testInstance, distanceTableAStarHeuristic);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    @Test\r\n    void optimalVsUCSDDynamicWithManhattanDistanceHeuristic(){\r\n        Map<I_ExplicitMap, String> maps = singleStronglyConnectedComponentGridMapsWithNames; // grid maps only!\r\n        for (I_ExplicitMap testMap :\r\n                maps.keySet()) {\r\n            for (I_Location source :\r\n                    testMap.getAllLocations()) {\r\n                for (I_Location target :\r\n                        testMap.getAllLocations()) {\r\n                    if ( ! source.equals(target)){\r\n                        Agent agent = new Agent(0, source.getCoordinate(), target.getCoordinate());\r\n                        MAPF_Instance testInstance = new MAPF_Instance(\r\n                                maps.get(testMap) + \" \" + agent, testMap, new Agent[]{agent});\r\n                        compareAStarAndUCS(aStar, new InstanceReport(), agent, testInstance, new UnitCostsAndManhattanDistance(agent.target));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static class RandomButStableCostsFrom1To10AndNoHeuristic implements AStarGAndH{\r\n        Map<Edge, Integer> randomButStableCosts = new HashMap<>();\r\n        Random rand;\r\n\r\n        private RandomButStableCostsFrom1To10AndNoHeuristic(Long seed) {\r\n            seed = Objects.requireNonNullElse(seed, 42L);\r\n            rand = new Random(seed);\r\n        }\r\n\r\n        @Override\r\n        public float getH(SingleAgentAStar_Solver.AStarState state) {\r\n            return 0;\r\n        }\r\n\r\n        @Override\r\n        public int cost(Move move) {\r\n            Edge edge = new Edge(move);\r\n            return randomButStableCosts.computeIfAbsent(edge, e -> rand.nextInt(10) + 1);\r\n        }\r\n\r\n        @Override\r\n        public boolean isConsistent() {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n//            SortedMap<Edge, Integer> sortedMap = new TreeMap<>(Comparator.comparingInt(e -> randomButStableCosts.get(e)));\r\n//            sortedMap.putAll(randomButStableCosts);\r\n            return randomButStableCosts.toString();\r\n        }\r\n    }\r\n\r\n    @Test\r\n    void optimalVsUCSWeightedEdges1(){\r\n        MAPF_Instance testInstance = instanceMaze1;\r\n        Agent agent = testInstance.agents.get(0);\r\n        AStarGAndH randomStableCosts = new RandomButStableCostsFrom1To10AndNoHeuristic((long) (agent.hashCode()));\r\n\r\n        compareAStarAndUCS(aStar, instanceReport, agent, testInstance, randomStableCosts);\r\n    }\r\n    @Test\r\n    void optimalVsUCSWeightedEdges2(){\r\n        MAPF_Instance testInstance = instanceMaze2;\r\n        Agent agent = testInstance.agents.get(0);\r\n        AStarGAndH randomStableCosts = new RandomButStableCostsFrom1To10AndNoHeuristic((long) (agent.hashCode()));\r\n\r\n        compareAStarAndUCS(aStar, instanceReport, agent, testInstance, randomStableCosts);\r\n    }\r\n    @Test\r\n    void optimalVsUCSWeightedEdges3(){\r\n        MAPF_Instance testInstance = instanceMaze3;\r\n        Agent agent = testInstance.agents.get(0);\r\n        AStarGAndH randomStableCosts = new RandomButStableCostsFrom1To10AndNoHeuristic((long) (agent.hashCode()));\r\n\r\n        compareAStarAndUCS(aStar, instanceReport, agent, testInstance, randomStableCosts);\r\n    }\r\n    @Test\r\n    void optimalVsUCSWeightedEdges4(){\r\n        MAPF_Instance testInstance = instanceMaze4;\r\n        Agent agent = testInstance.agents.get(0);\r\n        AStarGAndH randomStableCosts = new RandomButStableCostsFrom1To10AndNoHeuristic((long) (agent.hashCode()));\r\n\r\n        compareAStarAndUCS(aStar, instanceReport, agent, testInstance, randomStableCosts);\r\n    }\r\n    @Test\r\n    void optimalVsUCSWeightedEdgesDynamic(){\r\n        Map<I_ExplicitMap, String> maps = singleStronglyConnectedComponentMapsWithNames;\r\n        for (I_ExplicitMap testMap :\r\n                maps.keySet()) {\r\n            for (I_Location source :\r\n                    testMap.getAllLocations()) {\r\n                for (I_Location target :\r\n                        testMap.getAllLocations()) {\r\n                    if ( ! source.equals(target)){\r\n                        Agent agent = new Agent(0, source.getCoordinate(), target.getCoordinate());\r\n                        MAPF_Instance testInstance = new MAPF_Instance(\r\n                                maps.get(testMap) + \" \" + agent, testMap, new Agent[]{agent});\r\n                        AStarGAndH randomStableCosts = new RandomButStableCostsFrom1To10AndNoHeuristic((long) (agent.hashCode()));\r\n                        compareAStarAndUCS(aStar, new InstanceReport(), agent, testInstance, randomStableCosts);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void compareAStarAndUCS(I_Solver aStar, InstanceReport instanceReport, Agent agent, MAPF_Instance testInstance, AStarGAndH costFunction) {\r\n        RunParameters aStarRunParameters = new RunParameters_SAAStar(instanceReport, costFunction);\r\n\r\n        String identifier = testInstance.name + \" \" + agent.source + \" to \" + agent.target;\r\n        System.out.println(\"\\n\" + identifier);\r\n\r\n        Solution aStarSolution = aStar.solve(testInstance, aStarRunParameters);\r\n        List<Integer> aSTsarPlanCosts = null;\r\n        if (aStarSolution != null){\r\n            List<I_Location> aStarPlanLocations = planLocations(aStarSolution.getPlanFor(agent));\r\n            aSTsarPlanCosts = getCosts(agent, costFunction, aStarPlanLocations);\r\n            System.out.println(\"AStar:\");\r\n            System.out.println(aStarPlanLocations);\r\n            System.out.println(aSTsarPlanCosts);\r\n        }\r\n        else{\r\n            System.out.println(\"AStar Didn't Solve!!!\");\r\n        }\r\n\r\n        List<I_Location> UCSPlanLocations = NoStateTimeSearches.uniformCostSearch(testInstance.map.getMapLocation(agent.target),\r\n                testInstance.map.getMapLocation(agent.source), costFunction, agent);\r\n        List<Integer> UCSPlanCosts = null;\r\n        if (UCSPlanLocations != null){\r\n            UCSPlanCosts = getCosts(agent, costFunction, UCSPlanLocations);\r\n            System.out.println(\"UCS:\");\r\n            System.out.println(UCSPlanLocations);\r\n            System.out.println(UCSPlanCosts);\r\n        }\r\n        else{\r\n            System.out.println(\"UCS Didn't Solve!!!\");\r\n        }\r\n\r\n\r\n        System.out.println(\"Costs were:\");\r\n        System.out.println(costFunction);\r\n\r\n        assertNotNull(aStarSolution);\r\n        assertNotNull(UCSPlanLocations);\r\n\r\n        int costAStar = 0;\r\n        int costUCS = 0;\r\n        for (int i = 0; i < Math.max(aSTsarPlanCosts.size(), UCSPlanCosts.size()); i++) {\r\n            if (i < aSTsarPlanCosts.size()){\r\n                costAStar += aSTsarPlanCosts.get(i);\r\n            }\r\n            if (i < UCSPlanCosts.size()){\r\n                costUCS += UCSPlanCosts.get(i);\r\n            }\r\n        }\r\n        assertEquals(costAStar, costUCS);\r\n    }\r\n\r\n    @NotNull\r\n    private static List<Integer> getCosts(Agent agent, AStarGAndH costFunction, List<I_Location> UCSPlanLocations) {\r\n        List<Integer> UCSPlanCosts = new ArrayList<>();\r\n        UCSPlanCosts.add(0);\r\n        I_Location prev = null;\r\n        for (I_Location curr :\r\n                UCSPlanLocations) {\r\n            if (prev != null){\r\n                UCSPlanCosts.add(costFunction.cost(new Move(agent, 1, prev, curr)));\r\n            }\r\n            prev = curr;\r\n        }\r\n        return UCSPlanCosts;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/BasicMAPF/Solvers/AStar/SingleAgentAStar_SolverTest.java b/src/test/java/BasicMAPF/Solvers/AStar/SingleAgentAStar_SolverTest.java
--- a/src/test/java/BasicMAPF/Solvers/AStar/SingleAgentAStar_SolverTest.java	(revision b7dee42a7e06e50107bd2d08be8437bc03f0d8b2)
+++ b/src/test/java/BasicMAPF/Solvers/AStar/SingleAgentAStar_SolverTest.java	(date 1686151799310)
@@ -1,6 +1,7 @@
 package BasicMAPF.Solvers.AStar;
 
 import BasicMAPF.Instances.Maps.Coordinates.Coordinate_2D;
+import BasicMAPF.Instances.Maps.Coordinates.I_Coordinate;
 import BasicMAPF.Solvers.AStar.CostsAndHeuristics.AStarGAndH;
 import BasicMAPF.Solvers.AStar.CostsAndHeuristics.DistanceTableAStarHeuristic;
 import BasicMAPF.Solvers.AStar.CostsAndHeuristics.UnitCostsAndManhattanDistance;
@@ -219,6 +220,41 @@
 
     }
 
+    @Test
+    void largeNumberOfConstraints(){
+        MAPF_Instance testInstance = instanceEmpty1;
+        Agent agent = testInstance.agents.get(0);
+        List<I_Location> locations = new ArrayList<>();
+        for (int i = 0; i <= 5; i++) {
+            for (int j = 0; j <= 5; j++) {
+                I_Coordinate newCoor = new Coordinate_2D(i, j);
+                I_Location newLocation = instanceEmpty1.map.getMapLocation(newCoor);
+                locations.add(newLocation);
+            }
+        }
+        Random rand = new Random();
+        rand.setSeed(10);
+        ConstraintSet constraints = new ConstraintSet();
+        Set<I_Location> checkDuplicates = new HashSet<I_Location>();
+        for (int t = 1; t <= 30; t++) {
+            for (int j = 0; j < 10; j++) {
+                I_Location randomLocation = locations.get(rand.nextInt(locations.size()));
+                if (checkDuplicates.contains(randomLocation)){
+                    j--;
+                    continue;
+                }
+                checkDuplicates.add(randomLocation);
+                Constraint constraint = new Constraint(agent, t, null, randomLocation);
+                constraints.add(constraint);
+            }
+            checkDuplicates = new HashSet<I_Location>();
+        }
+        RunParameters parameters = new RunParameters(constraints);
+
+        Solution solved = aStar.solve(testInstance, parameters);
+        assertNotNull(solved);
+    }
+
     @Test
     void circleOptimalityNorthwestToSoutheast(){
         MAPF_Instance testInstance = instanceCircle2;
@@ -435,7 +471,7 @@
         assertEquals(9, solved1.getPlanFor(agent).size());
     }
 
-    private class UnitCostAndNoHeuristic implements AStarGAndH {
+    public static class UnitCostAndNoHeuristic implements AStarGAndH {
         @Override
         public float getH(SingleAgentAStar_Solver.AStarState state) {
             return 0;
@@ -457,9 +493,9 @@
         }
     }
 
-    private final AStarGAndH unitCostAndNoHeuristic = new UnitCostAndNoHeuristic();
+    public final AStarGAndH unitCostAndNoHeuristic = new UnitCostAndNoHeuristic();
 
-    private static List<I_Location> planLocations(SingleAgentPlan planFromAStar) {
+    public static List<I_Location> planLocations(SingleAgentPlan planFromAStar) {
         List<I_Location> aStarPlanLocations = new ArrayList<>();
         for (Move move :
                 planFromAStar) {
@@ -561,11 +597,11 @@
         }
     }
 
-    private static class RandomButStableCostsFrom1To10AndNoHeuristic implements AStarGAndH{
+    public static class RandomButStableCostsFrom1To10AndNoHeuristic implements AStarGAndH{
         Map<Edge, Integer> randomButStableCosts = new HashMap<>();
         Random rand;
 
-        private RandomButStableCostsFrom1To10AndNoHeuristic(Long seed) {
+        public RandomButStableCostsFrom1To10AndNoHeuristic(Long seed) {
             seed = Objects.requireNonNullElse(seed, 42L);
             rand = new Random(seed);
         }
@@ -647,7 +683,7 @@
         }
     }
 
-    private void compareAStarAndUCS(I_Solver aStar, InstanceReport instanceReport, Agent agent, MAPF_Instance testInstance, AStarGAndH costFunction) {
+    public void compareAStarAndUCS(I_Solver aStar, InstanceReport instanceReport, Agent agent, MAPF_Instance testInstance, AStarGAndH costFunction) {
         RunParameters aStarRunParameters = new RunParameters_SAAStar(instanceReport, costFunction);
 
         String identifier = testInstance.name + " " + agent.source + " to " + agent.target;
@@ -700,7 +736,7 @@
     }
 
     @NotNull
-    private static List<Integer> getCosts(Agent agent, AStarGAndH costFunction, List<I_Location> UCSPlanLocations) {
+    public static List<Integer> getCosts(Agent agent, AStarGAndH costFunction, List<I_Location> UCSPlanLocations) {
         List<Integer> UCSPlanCosts = new ArrayList<>();
         UCSPlanCosts.add(0);
         I_Location prev = null;
Index: src/main/java/BasicMAPF/Solvers/A_Solver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package BasicMAPF.Solvers;\r\n\r\nimport BasicMAPF.Instances.MAPF_Instance;\r\nimport Environment.Metrics.InstanceReport;\r\nimport Environment.Metrics.S_Metrics;\r\n\r\nimport java.io.IOException;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Paths;\r\nimport java.util.Date;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n/**\r\n * Performs that functionality that is common to all solvers.\r\n */\r\npublic abstract class A_Solver implements I_Solver{\r\n    protected final static long DEFAULT_TIMEOUT = 5*60*1000; //5 minutes\r\n    protected final static String processorInfo = getProcessorInfo();\r\n    protected long maximumRuntime;\r\n    protected long softTimeout;\r\n    protected InstanceReport instanceReport;\r\n    protected boolean commitReport;\r\n\r\n    protected long startTime;\r\n    protected long startDate;\r\n    protected long endTime;\r\n    protected boolean abortedForTimeout;\r\n    protected int totalLowLevelNodesGenerated;\r\n    protected int totalLowLevelNodesExpanded;\r\n    protected int totalLowLevelTimeMS;\r\n    protected int totalLowLevelCalls;\r\n    public String name;\r\n\r\n    /**\r\n     * This implementation provides a skeleton for running a solver. You can override any of the invoked methods, but if\r\n     * you do, it is recommended to also call the implementation defined in this class at some point during your implementation.\r\n     * You can also completely override this method and implement a different workflow, while using the methods defined\r\n     * in this class as services.\r\n     * @param instance {@inheritDoc}\r\n     * @param parameters {@inheritDoc}\r\n     * @return {@inheritDoc}\r\n     */\r\n    @Override\r\n    public Solution solve(MAPF_Instance instance, RunParameters parameters) {\r\n        init(instance, parameters);\r\n        Solution solution = runAlgorithm(instance, parameters);\r\n        writeMetricsToReport(solution);\r\n        tryCommitReport();\r\n        releaseMemory();\r\n        return solution;\r\n    }\r\n\r\n    /*  = initialization =  */\r\n\r\n    /**\r\n     * Prepares for a run. Must initialize all fields, making sure that no data from a previous run pollutes this run.\r\n     * @param instance an instance that we are about to solve.\r\n     * @param parameters parameters for this coming run.\r\n     */\r\n    protected void init(MAPF_Instance instance, RunParameters parameters){\r\n        if(instance == null || parameters == null){throw new IllegalArgumentException();}\r\n\r\n        this.startTime = getCurrentTimeMS_NSAccuracy();\r\n        this.startDate = System.currentTimeMillis();\r\n        this.endTime = 0;\r\n        this.abortedForTimeout = false;\r\n        this.totalLowLevelNodesGenerated = 0;\r\n        this.totalLowLevelNodesExpanded = 0;\r\n        this.totalLowLevelTimeMS = 0;\r\n        this.totalLowLevelCalls = 0;\r\n        this.maximumRuntime = (parameters.timeout >= 0) ? parameters.timeout : DEFAULT_TIMEOUT;\r\n        this.softTimeout = Math.min(parameters.softTimeout, this.maximumRuntime);\r\n        this.instanceReport = parameters.instanceReport == null ? S_Metrics.newInstanceReport()\r\n                : parameters.instanceReport;\r\n        // if we were given a report, we should leave it be. If we created our report locally, then it is unreachable\r\n        // outside the class, and should therefore be committed.\r\n        this.commitReport = parameters.instanceReport == null;\r\n    }\r\n\r\n    public static long getCurrentTimeMS_NSAccuracy() {\r\n        return TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);\r\n    }\r\n\r\n    /*  = algorithm =  */\r\n\r\n    protected abstract Solution runAlgorithm(MAPF_Instance instance, RunParameters parameters);\r\n\r\n    protected void digestSubproblemReport(InstanceReport subproblemReport) {\r\n        Integer statesGenerated = subproblemReport.getIntegerValue(InstanceReport.StandardFields.generatedNodesLowLevel);\r\n        this.totalLowLevelNodesGenerated += statesGenerated==null ? 0 : statesGenerated;\r\n        Integer statesExpanded = subproblemReport.getIntegerValue(InstanceReport.StandardFields.expandedNodesLowLevel);\r\n        this.totalLowLevelNodesExpanded += statesExpanded==null ? 0 : statesExpanded;\r\n        Integer totalLowLevelTimeMS = subproblemReport.getIntegerValue(InstanceReport.StandardFields.elapsedTimeMS);\r\n        this.totalLowLevelTimeMS += totalLowLevelTimeMS==null ? 0 : totalLowLevelTimeMS;\r\n        this.totalLowLevelCalls++;\r\n    }\r\n\r\n    /*  = wind down =  */\r\n\r\n    /**\r\n     * Writes metrics about the run and the solution to {@link #instanceReport}.\r\n     */\r\n    protected void writeMetricsToReport(Solution solution){\r\n        this.endTime = getCurrentTimeMS_NSAccuracy();\r\n\r\n        instanceReport.putIntegerValue(InstanceReport.StandardFields.timeoutThresholdMS, (int) this.maximumRuntime);\r\n        instanceReport.putStringValue(InstanceReport.StandardFields.startDateTime, new Date(startDate).toString());\r\n        instanceReport.putStringValue(InstanceReport.StandardFields.processorInfo, processorInfo);\r\n        instanceReport.putIntegerValue(InstanceReport.StandardFields.elapsedTimeMS, (int)(endTime-startTime));\r\n        if(solution != null){\r\n            instanceReport.putStringValue(InstanceReport.StandardFields.solution, solution.toString());\r\n            instanceReport.putIntegerValue(InstanceReport.StandardFields.solved, 1);\r\n        }\r\n        else{\r\n            instanceReport.putIntegerValue(InstanceReport.StandardFields.solved, 0);\r\n        }\r\n        instanceReport.putIntegerValue(InstanceReport.StandardFields.generatedNodesLowLevel, this.totalLowLevelNodesGenerated);\r\n        instanceReport.putIntegerValue(InstanceReport.StandardFields.expandedNodesLowLevel, this.totalLowLevelNodesExpanded);\r\n        instanceReport.putIntegerValue(InstanceReport.StandardFields.totalLowLevelTimeMS, this.totalLowLevelTimeMS);\r\n        instanceReport.putIntegerValue(InstanceReport.StandardFields.totalLowLevelCalls, this.totalLowLevelCalls);\r\n    }\r\n\r\n    private static String getProcessorInfo() {\r\n        try (java.util.stream.Stream<String> lines = Files.lines(Paths.get(\"/proc/cpuinfo\"))) {\r\n                    return lines.filter(line -> line.startsWith(\"model name\"))\r\n                    .map(line -> line.replaceAll(\".*: \", \"\"))\r\n                    .findFirst().orElse(\"\");\r\n        } catch (IOException e) {\r\n            return \"N/A\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Commits the report if {@link #commitReport} is true.\r\n     */\r\n    protected void tryCommitReport(){\r\n        if(commitReport){\r\n            try {\r\n                instanceReport.commit();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases memory held by the solver.\r\n     *\r\n     * This frees as much memory as possible, so that running multiple solvers in succession would not cause later\r\n     * solvers to slow down or fail.\r\n     * This also helps make sure that successive runs on the same solver object would remain independent, though the\r\n     * responsibility for this lies with {@link #init(MAPF_Instance, RunParameters)}.\r\n     */\r\n    protected void releaseMemory(){\r\n        this.instanceReport = null;\r\n        this.startTime = 0;\r\n        this.endTime = 0;\r\n    }\r\n\r\n    /*  = utilities =  */\r\n\r\n    protected boolean checkTimeout() {\r\n        if(getCurrentTimeMS_NSAccuracy() - startTime > maximumRuntime){\r\n            this.abortedForTimeout = true;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    protected boolean checkSoftTimeout() {\r\n        return getCurrentTimeMS_NSAccuracy() - startTime > softTimeout;\r\n    }\r\n\r\n    @Override\r\n    public String name() {\r\n        return this.name;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/BasicMAPF/Solvers/A_Solver.java b/src/main/java/BasicMAPF/Solvers/A_Solver.java
--- a/src/main/java/BasicMAPF/Solvers/A_Solver.java	(revision b7dee42a7e06e50107bd2d08be8437bc03f0d8b2)
+++ b/src/main/java/BasicMAPF/Solvers/A_Solver.java	(date 1686582285489)
@@ -110,6 +110,7 @@
         if(solution != null){
             instanceReport.putStringValue(InstanceReport.StandardFields.solution, solution.toString());
             instanceReport.putIntegerValue(InstanceReport.StandardFields.solved, 1);
+            instanceReport.putSolution(solution);
         }
         else{
             instanceReport.putIntegerValue(InstanceReport.StandardFields.solved, 0);
Index: src/test/java/BasicMAPF/Solvers/ConstraintsAndConflicts/ConflictManagement/CorridorConflictManagerTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package BasicMAPF.Solvers.ConstraintsAndConflicts.ConflictManagement;\r\n\r\nimport BasicMAPF.Instances.Agent;\r\nimport BasicMAPF.Instances.InstanceBuilders.InstanceBuilder_MovingAI;\r\nimport BasicMAPF.Instances.InstanceManager;\r\nimport BasicMAPF.Instances.InstanceProperties;\r\nimport BasicMAPF.Instances.MAPF_Instance;\r\nimport BasicMAPF.Solvers.CBS.CBS_Solver;\r\nimport BasicMAPF.Solvers.I_Solver;\r\nimport BasicMAPF.Solvers.RunParameters;\r\nimport BasicMAPF.Solvers.Solution;\r\nimport Environment.IO_Package.IO_Manager;\r\nimport Environment.Metrics.InstanceReport;\r\nimport Environment.Metrics.S_Metrics;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\n\r\nimport static BasicMAPF.TestConstants.Agents.agent13to10;\r\nimport static BasicMAPF.TestConstants.Agents.agent30to33;\r\nimport static BasicMAPF.TestConstants.Maps.mapHLong;\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\n/**\r\n * Tests by comparing solutions when using CBS with and without corridor reasoning.\r\n */\r\nclass CorridorConflictManagerTest {\r\n\r\n    private MAPF_Instance instanceHFromPaper = new MAPF_Instance(\"instanceHFromPaper\", mapHLong,\r\n            new Agent[]{agent30to33, agent13to10});\r\n    I_Solver corridorSolver = new CBS_Solver(null,null,null,null,null,true, null, null);\r\n\r\n    void validate(Solution solution, int numAgents, int optimalSOC, int optimalMakespan, MAPF_Instance instance){\r\n        assertTrue(solution.isValidSolution()); //is valid (no conflicts)\r\n        assertTrue(solution.solves(instance));\r\n\r\n        assertEquals(numAgents, solution.size()); // solution includes all agents\r\n        assertEquals(optimalSOC, solution.sumIndividualCosts()); // SOC is optimal\r\n        assertEquals(optimalMakespan, solution.makespan()); // makespan is optimal\r\n    }\r\n\r\n    @Test\r\n    void HMapFromPaperUsesCorridorReasoning() {\r\n        MAPF_Instance testInstance = instanceHFromPaper;\r\n        InstanceReport instanceReport = new InstanceReport();\r\n        Solution solved = corridorSolver.solve(testInstance, new RunParameters(instanceReport));\r\n\r\n        System.out.println(solved.readableToString());\r\n        validate(solved, 2, 14, 9, testInstance);\r\n        // did it correctly use corridor reasoning?\r\n        assertEquals(1, instanceReport.getIntegerValue(InstanceReport.StandardFields.expandedNodes));\r\n    }\r\n\r\n    /**\r\n     * This contains diverse instances\r\n     */\r\n    @Test\r\n    void comparativeDiverseTest(){\r\n        S_Metrics.clearAll();\r\n        boolean useAsserts = true;\r\n\r\n        I_Solver regularCBS = new CBS_Solver(null, null, null,\r\n                null, null, false, null, null);\r\n        String nameBaseline = \"regularCBS\";\r\n        I_Solver corridorCBS = new CBS_Solver(null, null, null,\r\n                null, null, true, null, null);\r\n        String nameExperimental = \"corridorCBS\";\r\n        String path = IO_Manager.buildPath( new String[]{   IO_Manager.testResources_Directory,\r\n                \"ComparativeDiverseTestSet\"});\r\n        InstanceManager instanceManager = new InstanceManager(path, new InstanceBuilder_MovingAI(),\r\n//                new InstanceProperties(null, -1d, new int[]{5, 10, 15, 20, 25}));\r\n                new InstanceProperties(null, -1d, new int[]{5, 10, 15}));\r\n\r\n        // run all instances on both solvers. this code is mostly copied from Environment.Experiment.\r\n        MAPF_Instance instance = null;\r\n//        long timeout = 60 /*seconds*/   *1000L;\r\n        long timeout = 10 /*seconds*/   *1000L;\r\n        int solvedByBaseline = 0;\r\n        int solvedByExperimental = 0;\r\n        int runtimeBaseline = 0;\r\n        int runtimeExperimental = 0;\r\n        while ((instance = instanceManager.getNextInstance()) != null) {\r\n            System.out.println(\"---------- solving \"  + instance.extendedName + \" with \" + instance.agents.size() + \" agents ----------\");\r\n\r\n            // run baseline (without the improvement)\r\n            //build report\r\n            InstanceReport reportBaseline = S_Metrics.newInstanceReport();\r\n            reportBaseline.putStringValue(InstanceReport.StandardFields.experimentName, \"comparativeDiverseTest\");\r\n            reportBaseline.putStringValue(InstanceReport.StandardFields.instanceName, instance.name);\r\n            reportBaseline.putIntegerValue(InstanceReport.StandardFields.numAgents, instance.agents.size());\r\n            reportBaseline.putStringValue(InstanceReport.StandardFields.solver, \"regularCBS\");\r\n\r\n            RunParameters runParametersBaseline = new RunParameters(timeout, null, reportBaseline, null);\r\n\r\n            //solve\r\n            Solution solutionBaseline = regularCBS.solve(instance, runParametersBaseline);\r\n\r\n            // run experimentl (with the improvement)\r\n            //build report\r\n            InstanceReport reportExperimental = S_Metrics.newInstanceReport();\r\n            reportExperimental.putStringValue(InstanceReport.StandardFields.experimentName, \"comparativeDiverseTest\");\r\n            reportExperimental.putStringValue(InstanceReport.StandardFields.instanceName, instance.name);\r\n            reportExperimental.putIntegerValue(InstanceReport.StandardFields.numAgents, instance.agents.size());\r\n            reportExperimental.putStringValue(InstanceReport.StandardFields.solver, \"corridorCBS\");\r\n\r\n            RunParameters runParametersExperimental = new RunParameters(timeout, null, reportExperimental, null);\r\n\r\n            //solve\r\n            Solution solutionExperimental = corridorCBS.solve(instance, runParametersExperimental);\r\n\r\n            // compare\r\n\r\n            boolean baselineSolved = solutionBaseline != null;\r\n            solvedByBaseline += baselineSolved ? 1 : 0;\r\n            boolean experimentalSolved = solutionExperimental != null;\r\n            solvedByExperimental += experimentalSolved ? 1 : 0;\r\n            System.out.println(nameBaseline + \" Solved?: \" + (baselineSolved ? \"yes\" : \"no\") +\r\n                    \" ; \" + nameExperimental + \" solved?: \" + (experimentalSolved ? \"yes\" : \"no\"));\r\n\r\n            if(solutionBaseline != null){\r\n                boolean valid = solutionBaseline.solves(instance);\r\n                System.out.print(nameBaseline + \" Valid?: \" + (valid ? \"yes\" : \"no\"));\r\n                if (useAsserts) assertTrue(valid);\r\n            }\r\n\r\n            if(solutionExperimental != null){\r\n                boolean valid = solutionExperimental.solves(instance);\r\n                System.out.println(\" \" + nameExperimental + \" Valid?: \" + (valid ? \"yes\" : \"no\"));\r\n                if (useAsserts) assertTrue(valid);\r\n            }\r\n\r\n            if(solutionBaseline != null && solutionExperimental != null){\r\n                int optimalCost = solutionBaseline.sumIndividualCosts();\r\n                int costWeGot = solutionExperimental.sumIndividualCosts();\r\n                boolean optimal = optimalCost==costWeGot;\r\n                System.out.println(nameExperimental + \" cost is \" + (optimal ? \"optimal (\" + costWeGot +\")\" :\r\n                        (\"not optimal (\" + costWeGot + \" instead of \" + optimalCost + \")\")));\r\n                reportBaseline.putIntegerValue(\"Cost Delta\", costWeGot - optimalCost);\r\n                reportExperimental.putIntegerValue(\"Cost Delta\", costWeGot - optimalCost);\r\n                if (useAsserts) assertEquals(optimalCost, costWeGot);\r\n\r\n                // runtimes\r\n                runtimeBaseline += reportBaseline.getIntegerValue(InstanceReport.StandardFields.elapsedTimeMS);\r\n                runtimeExperimental += reportExperimental.getIntegerValue(InstanceReport.StandardFields.elapsedTimeMS);\r\n                reportBaseline.putIntegerValue(\"Runtime Delta\",\r\n                        reportExperimental.getIntegerValue(InstanceReport.StandardFields.elapsedTimeMS)\r\n                                - reportBaseline.getIntegerValue(InstanceReport.StandardFields.elapsedTimeMS));\r\n            }\r\n        }\r\n\r\n        System.out.println(\"--- TOTALS: ---\");\r\n        System.out.println(\"timeout for each (seconds): \" + (timeout/1000));\r\n        System.out.println(nameBaseline + \" solved: \" + solvedByBaseline);\r\n        System.out.println(nameExperimental + \" solved: \" + solvedByExperimental);\r\n        System.out.println(\"runtime totals (instances where both solved) :\");\r\n        System.out.println(nameBaseline + \" time: \" + runtimeBaseline);\r\n        System.out.println(nameExperimental + \" time: \" + runtimeExperimental);\r\n\r\n        //save results\r\n        DateFormat dateFormat = S_Metrics.defaultDateFormat;\r\n        String resultsOutputDir = IO_Manager.buildPath(new String[]{   System.getProperty(\"user.home\"), \"CBS_Tests\"});\r\n        File directory = new File(resultsOutputDir);\r\n        if (! directory.exists()){\r\n            directory.mkdir();\r\n        }\r\n        String updatedPath = resultsOutputDir + \"\\\\results \" + dateFormat.format(System.currentTimeMillis()) + \".csv\";\r\n        try {\r\n            S_Metrics.exportCSV(new FileOutputStream(updatedPath),\r\n                    new String[]{\r\n                            InstanceReport.StandardFields.instanceName,\r\n                            InstanceReport.StandardFields.numAgents,\r\n                            InstanceReport.StandardFields.timeoutThresholdMS,\r\n                            InstanceReport.StandardFields.solved,\r\n                            InstanceReport.StandardFields.elapsedTimeMS,\r\n                            \"Runtime Delta\",\r\n                            InstanceReport.StandardFields.solutionCost,\r\n                            \"Cost Delta\",\r\n                            InstanceReport.StandardFields.totalLowLevelTimeMS,\r\n                            InstanceReport.StandardFields.generatedNodes,\r\n                            InstanceReport.StandardFields.expandedNodes,\r\n                            InstanceReport.StandardFields.generatedNodesLowLevel,\r\n                            InstanceReport.StandardFields.expandedNodesLowLevel});\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/BasicMAPF/Solvers/ConstraintsAndConflicts/ConflictManagement/CorridorConflictManagerTest.java b/src/test/java/BasicMAPF/Solvers/ConstraintsAndConflicts/ConflictManagement/CorridorConflictManagerTest.java
--- a/src/test/java/BasicMAPF/Solvers/ConstraintsAndConflicts/ConflictManagement/CorridorConflictManagerTest.java	(revision b7dee42a7e06e50107bd2d08be8437bc03f0d8b2)
+++ b/src/test/java/BasicMAPF/Solvers/ConstraintsAndConflicts/ConflictManagement/CorridorConflictManagerTest.java	(date 1686649920575)
@@ -5,6 +5,8 @@
 import BasicMAPF.Instances.InstanceManager;
 import BasicMAPF.Instances.InstanceProperties;
 import BasicMAPF.Instances.MAPF_Instance;
+import BasicMAPF.Solvers.AStar.SingleAgentAStarSIPP_Solver;
+import BasicMAPF.Solvers.AStar.SingleAgentAStar_Solver;
 import BasicMAPF.Solvers.CBS.CBS_Solver;
 import BasicMAPF.Solvers.I_Solver;
 import BasicMAPF.Solvers.RunParameters;
@@ -63,11 +65,11 @@
         S_Metrics.clearAll();
         boolean useAsserts = true;
 
-        I_Solver regularCBS = new CBS_Solver(null, null, null,
-                null, null, false, null, null);
+        I_Solver regularCBS = new CBS_Solver(new SingleAgentAStar_Solver(), null, null,
+                null, null, null, null, null);
         String nameBaseline = "regularCBS";
-        I_Solver corridorCBS = new CBS_Solver(null, null, null,
-                null, null, true, null, null);
+        I_Solver corridorCBS = new CBS_Solver(new SingleAgentAStarSIPP_Solver(), null, null,
+                null, null, null, null, null);
         String nameExperimental = "corridorCBS";
         String path = IO_Manager.buildPath( new String[]{   IO_Manager.testResources_Directory,
                 "ComparativeDiverseTestSet"});
Index: src/main/java/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import BasicMAPF.Instances.InstanceBuilders.I_InstanceBuilder;\r\nimport BasicMAPF.Instances.InstanceBuilders.InstanceBuilder_MovingAI;\r\nimport BasicMAPF.Instances.InstanceBuilders.InstanceBuilder_Warehouse;\r\nimport Environment.IO_Package.IO_Manager;\r\nimport BasicMAPF.Instances.InstanceBuilders.InstanceBuilder_BGU;\r\nimport BasicMAPF.Instances.InstanceManager;\r\nimport BasicMAPF.Instances.MAPF_Instance;\r\nimport Environment.Metrics.InstanceReport;\r\nimport Environment.Metrics.S_Metrics;\r\nimport BasicMAPF.Solvers.CBS.CBS_Solver;\r\nimport BasicMAPF.Solvers.RunParameters;\r\nimport BasicMAPF.Solvers.Solution;\r\nimport Environment.RunManagers.*;\r\nimport Environment.Visualization.I_VisualizeSolution;\r\nimport Environment.Visualization.GridSolutionVisualizer;\r\nimport org.apache.commons.cli.*;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.text.DateFormat;\r\nimport java.util.Arrays;\r\n\r\nimport static Environment.RunManagers.A_RunManager.verifyOutputPath;\r\n\r\n\r\n/**\r\n * We wanted to keep {@link #main(String[])} short and simple as possible\r\n * Things to consider before running:\r\n *      1. Check that the {@link #exampleResultsOutputDir} is correct\r\n *      2. Check that {@link #outputResults()} is as you need\r\n *      3. Running an experiment should be done through a {@link A_RunManager}.\r\n *          Solving a single Instance is also possible by giving a path.\r\n * For more information, view the examples below\r\n */\r\npublic class Main {\r\n\r\n    // where to put generated reports. The default is a new folder called MAPF_Results, under the user's home directory.\r\n    public static final String exampleResultsOutputDir = A_RunManager.DEFAULT_RESULTS_OUTPUT_DIR;\r\n    public static final String STR_AGENT_NUMS = \"agentNums\";\r\n    private static final String STR_MOVING_AI = \"MovingAI\";\r\n    private static final String STR_BGU = \"BGU\";\r\n    public static final String STR_INSTANCES_DIR = \"instancesDir\";\r\n    public static final String STR_INSTANCES_REGEX = \"instancesRegex\";\r\n    private static final String STR_WAREHOUSE = \"Warehouse\";\r\n    private static final String STR_RESULTS_DIR_OPTION = \"resultsOutputDir\";\r\n    private static final String STR_RESULTS_FILE_PREFIX = \"resultsFilePrefix\";\r\n\r\n    public static void main(String[] args) {\r\n        if (args.length > 0){\r\n            CLIMain(args);\r\n        }\r\n        else {\r\n            // Example\r\n            staticMain();\r\n        }\r\n    }\r\n\r\n    private static void CLIMain(String[] args) {\r\n        Options options = new Options();\r\n\r\n        Option skipOption = new Option(\"s\", \"skipAfterFail\", false,\r\n                \"To skip attempting the same instance with the same solver, but with more agents, if we already failed with less agents.\");\r\n        options.addOption(skipOption);\r\n\r\n        Option visualiseOption = new Option(\"v\", \"visualise\", false,\r\n                \"To visualise the solution. Only  works with grid maps!\");\r\n        options.addOption(visualiseOption);\r\n\r\n        Option nameOption = Option.builder(\"n\").longOpt(\"name\")\r\n                .argName(\"name\")\r\n                .hasArg()\r\n                .required(false)\r\n                .desc(\"Name for the experiment. Optional.\")\r\n                .build();\r\n        options.addOption(nameOption);\r\n\r\n        Option instancesDirOption = Option.builder(\"iDir\").longOpt(STR_INSTANCES_DIR)\r\n                .argName(STR_INSTANCES_DIR)\r\n                .hasArg()\r\n                .required(true)\r\n                .desc(\"Set the directory (path) where maps and instances are to be found. Required.\")\r\n                .build();\r\n        options.addOption(instancesDirOption);\r\n\r\n        Option resultsDirOption = Option.builder(\"resDir\").longOpt(STR_RESULTS_DIR_OPTION)\r\n                .argName(STR_RESULTS_DIR_OPTION)\r\n                .hasArg()\r\n                .required(false)\r\n                .desc(\"The directory (path) where results will be saved. Will be created if it doesn't exist. Optional.\")\r\n                .build();\r\n        options.addOption(resultsDirOption);\r\n\r\n        Option resultsFileOption = Option.builder(\"resPref\").longOpt(STR_RESULTS_FILE_PREFIX)\r\n                .argName(STR_RESULTS_FILE_PREFIX)\r\n                .hasArg()\r\n                .required(false)\r\n                .desc(\"The prefix to give results file names. Optional.\")\r\n                .build();\r\n        options.addOption(resultsFileOption);\r\n\r\n        Option instancesRegexOption = Option.builder(\"iRegex\").longOpt(STR_INSTANCES_REGEX)\r\n                .argName(STR_INSTANCES_REGEX)\r\n                .hasArg()\r\n                .required(false)\r\n                .desc(\"If given, only instances matching this Regex will be used. Optional.\")\r\n                .build();\r\n        options.addOption(instancesRegexOption);\r\n\r\n        Option InstancesFormatOption = Option.builder(\"iForm\").longOpt(\"instancesFormat\")\r\n                .argName(\"instancesFormat\")\r\n                .hasArg()\r\n                .required(false)\r\n                .desc(String.format(\"Set the format of the instances. \" +\r\n                        \"Supports %s format (https://movingai.com/benchmarks/formats.html) and %s format.\", STR_MOVING_AI, STR_BGU)\r\n                        + \" Optional (default is \" + STR_MOVING_AI + \").\")\r\n                .build();\r\n        options.addOption(InstancesFormatOption);\r\n\r\n        Option agentNumsOption = Option.builder(\"a\").longOpt(STR_AGENT_NUMS)\r\n                .argName(STR_AGENT_NUMS)\r\n                .hasArgs()\r\n                .required(true)\r\n                .valueSeparator(',')\r\n                .desc(\"Set the numbers of agents to try. Use ',' (comma) as a separator and no spaces.\" +\r\n                        \" Will use the maximum available if an instance does not have enough agents. Required.\")\r\n                .build();\r\n        options.addOption(agentNumsOption);\r\n\r\n        CommandLine cmd;\r\n        CommandLineParser parser = new DefaultParser();\r\n        HelpFormatter helper = new HelpFormatter();\r\n\r\n        try {\r\n            String instancesDir;\r\n            int[] agentNums = null;\r\n            I_InstanceBuilder instanceBuilder = new InstanceBuilder_MovingAI();\r\n            String experimentName = \"Unnamed Experiment\";\r\n            boolean skipAfterFail = false;\r\n            I_VisualizeSolution visualiser = null;\r\n            String instancesRegex = null;\r\n            String resultsOutputDir = null;\r\n            String optResultsFilePrefix = null;\r\n\r\n            // Parse arguments\r\n\r\n            cmd = parser.parse(options, args);\r\n\r\n            if(cmd.hasOption(\"s\")) {\r\n                System.out.println(\"skipAfterFail set: Will skip trying more agents for the same instance and solver after failing.\");\r\n                skipAfterFail = true;\r\n            }\r\n\r\n            if (cmd.hasOption(\"v\")) {\r\n                System.out.println(\"visualise set: Will visualise the solution.\");\r\n                visualiser = GridSolutionVisualizer::visualizeSolution;\r\n            }\r\n\r\n            if (cmd.hasOption(\"n\")) {\r\n                String optName = cmd.getOptionValue(\"name\");\r\n                System.out.println(\"Experiment Name: \" + optName);\r\n                experimentName = optName;\r\n            }\r\n\r\n            String optInstancesDir = cmd.getOptionValue(STR_INSTANCES_DIR);\r\n            System.out.println(\"Instances Dir: \" + optInstancesDir);\r\n            instancesDir = optInstancesDir;\r\n            if (! new File(instancesDir).exists()){\r\n                System.out.printf(\"Could not locate the provided instances dir (%s)\", instancesDir);\r\n                System.exit(0);\r\n            }\r\n\r\n            if(cmd.hasOption(\"resDir\")) {\r\n                String optResultsDir = cmd.getOptionValue(STR_RESULTS_DIR_OPTION);\r\n                System.out.println(\"Trying to set results dir to \" + optResultsDir);\r\n                resultsOutputDir = optResultsDir;\r\n                verifyOutputPath(resultsOutputDir);\r\n            }\r\n\r\n            if(cmd.hasOption(\"resPref\")) {\r\n                optResultsFilePrefix = cmd.getOptionValue(STR_RESULTS_FILE_PREFIX);\r\n            }\r\n\r\n            if (cmd.hasOption(STR_INSTANCES_REGEX)){\r\n                String optInstancesRegex = cmd.getOptionValue(STR_INSTANCES_REGEX);\r\n                System.out.println(\"Instances Regex: \" + optInstancesRegex);\r\n                instancesRegex = optInstancesRegex;\r\n            }\r\n\r\n            if (cmd.hasOption(\"iForm\")) {\r\n                String optInstancesFormat = cmd.getOptionValue(\"instancesFormat\");\r\n                System.out.println(\"Instances Format: \" + optInstancesFormat);\r\n                switch (optInstancesFormat) {\r\n                    case STR_MOVING_AI -> instanceBuilder = new InstanceBuilder_MovingAI();\r\n                    case STR_BGU -> instanceBuilder = new InstanceBuilder_BGU();\r\n                    case STR_WAREHOUSE -> instanceBuilder = new InstanceBuilder_Warehouse();\r\n                    default -> {\r\n                        System.out.printf(\"Unrecognized instance format: %s\", optInstancesFormat);\r\n                        System.exit(0);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                System.out.printf(\"Using default instance format %s\", STR_MOVING_AI);\r\n            }\r\n\r\n            String[] optAgents = cmd.getOptionValues(STR_AGENT_NUMS);\r\n            System.out.println(\"Agent nums: \" + Arrays.toString(optAgents));\r\n\r\n            try {\r\n                agentNums = Arrays.stream(optAgents).mapToInt(Integer::parseInt).toArray();\r\n            }\r\n            catch (NumberFormatException e){\r\n                System.out.printf(\"%s should be an array of integers, got %s\", STR_AGENT_NUMS, Arrays.toString(optAgents));\r\n                System.exit(0);\r\n            }\r\n\r\n            // Run!\r\n            new GenericRunManager(instancesDir, agentNums, instanceBuilder, experimentName, skipAfterFail, instancesRegex, resultsOutputDir, optResultsFilePrefix, visualiser)\r\n                    .runAllExperiments();\r\n\r\n        } catch (ParseException e) {\r\n            System.out.println(e.getMessage());\r\n            helper.printHelp(\"Usage:\", options);\r\n            System.exit(0);\r\n        }\r\n    }\r\n\r\n    private static void staticMain() {\r\n        if (verifyOutputPath(exampleResultsOutputDir)){\r\n            // will solve a single instance, print the solution, and start a visualization of the solution\r\n            solveOneInstanceWithVisualizationExample();\r\n            // will solve multiple instances and print a simple report for each instance\r\n            runMultipleExperimentsExample();\r\n            // will solve a set of instances. These instances have known optimal solution costs (found at\r\n            // src\\test\\resources\\TestingBenchmark\\Results.csv), and so can be used as a benchmark.\r\n            runTestingBenchmarkExperiment();\r\n            // all examples will also produce a report in CSV format, and save it to resultsOutputDir (see above)\r\n        }\r\n    }\r\n\r\n    public static void solveOneInstanceWithVisualizationExample(){\r\n        // write the reports to System.out\r\n        addConsoleAsOutputStream();\r\n\r\n        /*  =   Set Path   =*/\r\n        String path = IO_Manager.buildPath( new String[]{   IO_Manager.resources_Directory,\r\n                                                            \"Instances\", \"BGU_Instances\", \"den520d-10-0\"});\r\n        InstanceManager.InstancePath instancePath = new InstanceManager.InstancePath(path);\r\n\r\n\r\n        /*  =   Set Instance Manager   =  */\r\n        InstanceManager instanceManager = new InstanceManager(null, new InstanceBuilder_BGU());\r\n\r\n        MAPF_Instance instance = A_RunManager.getInstanceFromPath(instanceManager, instancePath);\r\n\r\n        // Solve\r\n        CBS_Solver solver = new CBS_Solver();\r\n        RunParameters runParameters = new RunParameters();\r\n        Solution solution = solver.solve(instance, runParameters);\r\n\r\n        //output results\r\n        System.out.println(solution.readableToString());\r\n        outputResults();\r\n\r\n        GridSolutionVisualizer.visualizeSolution(instance, solution, solver.name() + \" - \" + instance.extendedName);\r\n    }\r\n\r\n    public static void runMultipleExperimentsExample(){\r\n        RunManagerSimpleExample runManagerSimpleExample = new RunManagerSimpleExample();\r\n        runManagerSimpleExample.runAllExperiments();\r\n    }\r\n\r\n    public static void runTestingBenchmarkExperiment(){\r\n        TestingBenchmarkRunManager testingBenchmarkRunManager = new TestingBenchmarkRunManager();\r\n        testingBenchmarkRunManager.runAllExperiments();\r\n    }\r\n\r\n    private static void addConsoleAsOutputStream() {\r\n        try {\r\n            S_Metrics.addOutputStream(System.out, S_Metrics::instanceReportToHumanReadableString);\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * An example of a simple output of results to a file. It is best to handle this inside your custom\r\n     * {@link A_RunManager run managers} instead.\r\n     * Note that you can add more fields here, if you want metrics that are collected and not exported.\r\n     * Note that you can easily add other metrics which are not currently collected. see {@link S_Metrics}.\r\n     */\r\n    private static void outputResults() {\r\n        try {\r\n            Thread.sleep(30);\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        DateFormat dateFormat = S_Metrics.defaultDateFormat;\r\n        String updatedPath =  IO_Manager.buildPath(new String[]{exampleResultsOutputDir, \"results \" + dateFormat.format(System.currentTimeMillis())}) + \" .csv\";\r\n        try {\r\n            S_Metrics.exportCSV(new FileOutputStream(updatedPath),\r\n                    new String[]{   InstanceReport.StandardFields.experimentName,\r\n                                    InstanceReport.StandardFields.mapName,\r\n                                    InstanceReport.StandardFields.instanceName,\r\n                                    InstanceReport.StandardFields.numAgents,\r\n                                    InstanceReport.StandardFields.obstacleRate,\r\n                                    InstanceReport.StandardFields.solver,\r\n                                    InstanceReport.StandardFields.solved,\r\n                                    InstanceReport.StandardFields.valid,\r\n                                    InstanceReport.StandardFields.elapsedTimeMS,\r\n                                    InstanceReport.StandardFields.solutionCost,\r\n                                    InstanceReport.StandardFields.solution});\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        S_Metrics.clearReports();\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/Main.java b/src/main/java/Main.java
--- a/src/main/java/Main.java	(revision b7dee42a7e06e50107bd2d08be8437bc03f0d8b2)
+++ b/src/main/java/Main.java	(date 1682342162883)
@@ -18,6 +18,7 @@
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.OutputStream;
 import java.text.DateFormat;
 import java.util.Arrays;
 
@@ -261,7 +262,7 @@
 
         //output results
         System.out.println(solution.readableToString());
-        outputResults();
+        outputResults(solution);
 
         GridSolutionVisualizer.visualizeSolution(instance, solution, solver.name() + " - " + instance.extendedName);
     }
@@ -291,7 +292,7 @@
      * Note that you can add more fields here, if you want metrics that are collected and not exported.
      * Note that you can easily add other metrics which are not currently collected. see {@link S_Metrics}.
      */
-    private static void outputResults() {
+    private static void outputResults(Solution solution) {
         try {
             Thread.sleep(30);
         } catch (InterruptedException e) {
@@ -299,6 +300,7 @@
         }
         DateFormat dateFormat = S_Metrics.defaultDateFormat;
         String updatedPath =  IO_Manager.buildPath(new String[]{exampleResultsOutputDir, "results " + dateFormat.format(System.currentTimeMillis())}) + " .csv";
+        String updatedPathForSolution =  IO_Manager.buildPath(new String[]{exampleResultsOutputDir, "results " + dateFormat.format(System.currentTimeMillis())}) + " .txt";
         try {
             S_Metrics.exportCSV(new FileOutputStream(updatedPath),
                     new String[]{   InstanceReport.StandardFields.experimentName,
@@ -315,6 +317,14 @@
         } catch (IOException e) {
             e.printStackTrace();
         }
+
+        try {
+            OutputStream solutionOutputStream = new FileOutputStream(updatedPathForSolution);
+            solutionOutputStream.write(solution.toString().getBytes());
+            solutionOutputStream.flush();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
         S_Metrics.clearReports();
     }
 
Index: src/main/java/Environment/Metrics/S_Metrics.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Environment.Metrics;\r\n\r\n\r\nimport Environment.RunManagers.A_RunManager;\r\nimport java.io.*;\r\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.*;\r\n\r\n/**\r\n * This is a static class, responsible for collecting and exporting metrics generated during experiments.\r\n * Many of its functions are optional.\r\n * A minimal use case would include:\r\n * a. adding {@link InstanceReport}s with {@link #newInstanceReport()}, and storing the results of experiments in them.\r\n * b. calling {@link #exportCSV(OutputStream, String[])} with a {@link java.io.FileOutputStream}, and an array of header fields.\r\n *\r\n * Example of a more advanced usecase:\r\n * a. calling {@link #addOutputStream(OutputStream, InstanceReportToString, HeaderToString)} with various {@link java.io.OutputStream}s.\r\n * b. calling {@link #setHeader(String[])} to set a header (enables valid csv output).\r\n * c1. adding {@link InstanceReport}s with {@link #newInstanceReport()}, and adding the results of experiments to them.\r\n * c2. after each report is filled, calling {@link InstanceReport#commit()} to immediately output its contents to the\r\n * output streams.\r\n */\r\npublic class S_Metrics {\r\n    public static DateFormat defaultDateFormat = new SimpleDateFormat(\"yyyy-MM-dd_HH-mm_ss-SSS\");\r\n    private static final char CSV_DELIMITER = ',';\r\n\r\n    ////      MEMBERS      ////\r\n    /**\r\n     * Optional. Defines a header. Useful for formats such as CSV.\r\n     */\r\n    private static String[] header = new String[0];\r\n    /**\r\n     *\r\n     */\r\n    private final static List<InstanceReport> reports = new ArrayList<InstanceReport>();\r\n    // the following three lists are managed together, so that any index refers to the same OutputStream in outputStreams\r\n    /**\r\n     * OutputStreams for {@link InstanceReport#commit() comitted} {@link InstanceReport}s to be output to.\r\n     */\r\n    private static List<OutputStream> outputStreams = new ArrayList<OutputStream>();\r\n    /**\r\n     * Functions to convert {@link InstanceReport}s to strings for output.\r\n     */\r\n    private static List<InstanceReportToString> instanceReportToStringsForOSs = new ArrayList<InstanceReportToString>();\r\n    /**\r\n     * Functions to convert the header to String to output at the start of an output stream. Can contain nulls, meaning\r\n     * a header is not needed for the OutputStream of the same index.\r\n     */\r\n    private static List<HeaderToString> headerToStringsForOSs = new ArrayList<HeaderToString>();\r\n    ////      INTERFACES      ////\r\n    /**\r\n     * Defines a function which converts an {@link InstanceReport} to a String.\r\n     * This class contains static methods which comply with this interface, and may be used when this interface is\r\n     * required.\r\n     * @see #instanceReportToStringCSV(InstanceReport).\r\n     * @see #instanceReportToHumanReadableString(InstanceReport).\r\n     */\r\n    public interface InstanceReportToString{\r\n        String instanceReportToString(InstanceReport instanceReport);\r\n    }\r\n\r\n    /**\r\n     * Defines a function which converts a String array representing a header, to a String.\r\n     * {@link S_Metrics} contains static methods which comply with this interface, and may be used when this\r\n     * interface is required.\r\n     * @see #headerArrayToStringCSV(String[]).\r\n     */\r\n    public interface HeaderToString{\r\n        String headerToString(String[] headerArray);\r\n    }\r\n\r\n\r\n    ////      SETTERS AND GETTERS      ////\r\n\r\n    /**\r\n     * Sets the {@link #header} and outputs the new header to all relevant streams.\r\n     * @param newHeader the new header @NotNull\r\n     * @throws IOException if an I/O error occurs when outputing the new header to one of the streams.\r\n     */\r\n    public static void setHeaderAndOutputNewHeader(String[] newHeader) throws IOException {\r\n        if(newHeader != null){\r\n            S_Metrics.header = newHeader;\r\n            if(newHeader.length > 0 ){outputHeaderToAllRelevantStreams();}\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the {@link #header}. Doesn't output the new header to any streams.\r\n     * @param newHeader the new header @NotNull\r\n     */\r\n    public static void setHeader(String[] newHeader) throws IOException {\r\n        if(newHeader != null){\r\n            S_Metrics.header = newHeader;}\r\n    }\r\n\r\n    private static String[] getHeader() {\r\n        return Arrays.copyOf(S_Metrics.header, S_Metrics.header.length);\r\n    }\r\n\r\n    public static void clearHeader() {header = new String[0];}\r\n\r\n    /**\r\n     * Creates a new, empty, {@link InstanceReport}, saves a reference to it, and returns it.\r\n     * @return a new instance of {@link InstanceReport}.\r\n     */\r\n    public static InstanceReport newInstanceReport(){\r\n        InstanceReport newReport = new InstanceReport();\r\n        S_Metrics.reports.add(newReport);\r\n        return newReport;\r\n    }\r\n\r\n    /**\r\n     * Returns the most recently created {@link InstanceReport}.\r\n     * @return the most recently created {@link InstanceReport}.\r\n     */\r\n    public static InstanceReport getMostRecentInstanceReport(){\r\n        return S_Metrics.reports.get(S_Metrics.reports.size()-1);\r\n    }\r\n\r\n    public static boolean removeReport(InstanceReport report){\r\n        return S_Metrics.reports.remove(report);\r\n    }\r\n\r\n    public static void clearReports(){\r\n        S_Metrics.reports.clear();\r\n    }\r\n\r\n    public static List<InstanceReport> getAllReports(){\r\n        return List.copyOf(S_Metrics.reports);\r\n    }\r\n\r\n    /**\r\n     * Adds the given output stream to the list of OutputStreams. When {@link InstanceReport}s are committed, or when\r\n     * {@link #exportAll()} is called, {@link InstanceReport}s will be written to this given OutputStream.\r\n     * If headerToString isn't null, writes the current {@link #header} to the given {@link OutputStream}.\r\n     * @param outputStream an output stream.\r\n     * @param instanceReportToString function to convert {@link InstanceReport}s to Strings to write them to the given {@link OutputStream}.\r\n     * @param headerToString function to convert the header to String to write it to the given {@link OutputStream}. If null, header will not be written.\r\n     * @throws IOException if an I/O error occurs.\r\n     */\r\n    public static void addOutputStream(OutputStream outputStream, InstanceReportToString instanceReportToString,\r\n                                       HeaderToString headerToString) throws IOException {\r\n        if (outputStream != null && instanceReportToString != null) {\r\n            outputStreams.add(outputStream);\r\n            instanceReportToStringsForOSs.add(instanceReportToString);\r\n            headerToStringsForOSs.add(headerToString); // null is interpreted as \"no need for header\"\r\n            //output the header to the new stream if a header is needed and is set.\r\n            if(header.length > 0 && headerToString != null){\r\n                outputStream.write(headerToString.headerToString(header).getBytes());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds the given output stream to the list of OutputStreams. When {@link InstanceReport}s are committed, or when\r\n     * {@link #exportAll()} is called, {@link InstanceReport}s will be written to this given OutputStream.\r\n     * Doesn't write a header to the stream.\r\n     * @param outputStream an output stream.\r\n     * @param instanceReportToString function to convert {@link InstanceReport}s to Strings to write them to the given {@link OutputStream}.\r\n     * @throws IOException if an I/O error occurs.\r\n     */\r\n    public static void addOutputStream(OutputStream outputStream,\r\n                                       InstanceReportToString instanceReportToString) throws IOException {\r\n        addOutputStream(outputStream, instanceReportToString, null);\r\n    }\r\n\r\n    /**\r\n     * Adds the given output stream to the list of OutputStreams. When {@link InstanceReport}s are committed, or when\r\n     * {@link #exportAll()} is called, {@link InstanceReport}s will be written to this given OutputStream.\r\n     * Uses the default {@link InstanceReportToString}.\r\n     * Doesn't write a header to the stream.\r\n     * @param outputStream an output stream.\r\n     * @throws IOException if an I/O error occurs.\r\n     */\r\n    public static void addOutputStream(OutputStream outputStream) throws IOException {\r\n        addOutputStream(outputStream, S_Metrics::instanceReportToStringCSV, S_Metrics::headerArrayToStringCSV);\r\n    }\r\n\r\n    public static void addSolutionExportOutputStream(String pathName) throws IOException {\r\n        int index = S_Metrics.getAllReports().size() - 1;\r\n\r\n        if (A_RunManager.verifyOutputPath(pathName)) {\r\n            String fullPathName = pathName + \"/\" + index + \".txt\";\r\n            addOutputStream(new FileOutputStream(fullPathName), S_Metrics::instanceReportToSolutionString);\r\n        }\r\n    }\r\n\r\n\r\n    public static void removeOutputStream(OutputStream outputStream){\r\n        int streamIndex = outputStreams.indexOf(outputStream);\r\n        outputStreams.remove(streamIndex);\r\n        headerToStringsForOSs.remove(streamIndex);\r\n        instanceReportToStringsForOSs.remove(streamIndex);\r\n    }\r\n\r\n    public static void clearOutputStreams(){\r\n        outputStreams.clear();\r\n        headerToStringsForOSs.clear();\r\n        instanceReportToStringsForOSs.clear();\r\n    }\r\n\r\n    /**\r\n     * Clears all class fields, essentially resetting the class.\r\n     */\r\n    public static void clearAll(){\r\n        clearHeader();\r\n        clearReports();\r\n        clearOutputStreams();\r\n    }\r\n    ////      OUTPUT      ////\r\n\r\n    // nicetohave groupBy, which gets a comparator to group by\r\n    // nicetohave sort, which gets a comparator to sort by\r\n\r\n    ////    conversions to strings      ////\r\n\r\n    //      csv     //\r\n\r\n//    /**\r\n//     * Returns a string representation of the current {@link #header}, in a format compatible with CSV.\r\n//     * @return a string representation of the current {@link #header}, in a format compatible with CSV.\r\n//     */\r\n//    public static String currentHeaderToStringCSV(){\r\n//        return headerArrayToStringCSV(header);\r\n//    }\r\n\r\n    /**\r\n     * Returns a string representation of the given header, in a format compatible with CSV.\r\n     * @param delimiter the delimiter to use to delimit the fields.\r\n     * @return a string representation of the given header, in a format compatible with CSV.\r\n     */\r\n    private static String headerToStringCSV(String[] headerArray, char delimiter){\r\n        StringBuilder headerLine = new StringBuilder();\r\n        for(int i = 0 ; i < headerArray.length ; i++){\r\n            String field = headerArray[i];\r\n            headerLine.append(field);\r\n            if(i != headerArray.length - 1) {headerLine.append(delimiter);} //no delimiter after the last field\r\n        }\r\n        headerLine.append('\\n');\r\n        return headerLine.toString();\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the given header, in a format compatible with CSV.\r\n     * @return a string representation of the given header, in a format compatible with CSV.\r\n     */\r\n    public static String headerArrayToStringCSV(String[] headerArray){\r\n        return headerToStringCSV(headerArray, S_Metrics.CSV_DELIMITER);\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the information in an instanceReport, in a format compatible with CSV.\r\n     * Because CSV requires all lines adhere to a single header, only fields present in {@link #header} will be included.\r\n     * @param instanceReport the InstanceReport to convert to a string. @NotNull.\r\n     * @param delimiter the delimiter to use to delimit the fields.\r\n     * @return a string representation of the information in an instanceReport, in a format compatible with CSV.\r\n     */\r\n    private static String instanceReportToStringCSV(InstanceReport instanceReport, char delimiter, String[] headerArray){\r\n        StringBuilder reportLine = new StringBuilder();\r\n\r\n        for(int i = 0; i< headerArray.length ; i++){\r\n            String field = headerArray[i];\r\n            if(instanceReport.hasField(field)){\r\n                reportLine.append(wrapStringCSVSafety(instanceReport.getValue(field)));\r\n            }\r\n            if(i != headerArray.length - 1 ) {reportLine.append(delimiter);} //no delimiter after the last one\r\n        }\r\n        reportLine.append('\\n');\r\n        return reportLine.toString();\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the information in an instanceReport, in a format compatible with CSV.\r\n     * Because CSV requires all lines adhere to a single header, only fields present in {@link #header} will be included.\r\n     * @param instanceReport the InstanceReport to convert to a string. @NotNull.\r\n     * @return a string representation of the information in an instanceReport, in a format compatible with CSV.\r\n     */\r\n    public static String instanceReportToStringCSV(InstanceReport instanceReport){\r\n        return  instanceReportToStringCSV(instanceReport, S_Metrics.CSV_DELIMITER, S_Metrics.header);\r\n    }\r\n\r\n    /**\r\n     * Adds \"\" marks in case the string might contain ',' to make it safe for CSV.\r\n     * @param fieldValue - original value.\r\n     * @return\r\n     */\r\n    private static String wrapStringCSVSafety(String fieldValue) {\r\n        return \"\\\"\" + fieldValue + \"\\\"\";\r\n    }\r\n\r\n    //      human readable      //\r\n\r\n    /**\r\n     * Returns a string representation of the information in an instanceReport, in a format that is suitable for easy\r\n     * reading. Useful for outputing to a console to monitor the experiment.\r\n     * @param instanceReport the InstanceReport to convert to a string. @NotNull.\r\n     * @return a string representation of the information in an instanceReport, in a format readable format.\r\n     */\r\n    public static String instanceReportToHumanReadableString(InstanceReport instanceReport){\r\n        return instanceReport.toString() + '\\n';\r\n    }\r\n\r\n    public static String instanceReportToSolutionString(InstanceReport instanceReport) {\r\n        return instanceReport.getSolution() != null ? instanceReport.getSolution().toString(): \"\";\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the information in an instanceReport, in a format that is suitable for easy\r\n     * reading. Useful for outputing to a console to monitor the experiment.\r\n     * Skips outputting the solutions because they are long.\r\n     * @param instanceReport the InstanceReport to convert to a string. @NotNull.\r\n     * @return a string representation of the information in an instanceReport, in a format readable format.\r\n     */\r\n    public static String instanceReportToHumanReadableStringSkipSolutions(InstanceReport instanceReport){\r\n        return instanceReport.toString(Set.of(InstanceReport.StandardFields.solution)) + '\\n';\r\n    }\r\n\r\n    // nicetohave tosrting json\r\n\r\n    ////      outputing to the streams      ////\r\n\r\n    private static void outputHeaderToStream(OutputStream outputStream, String[] headerArray,\r\n                                             HeaderToString headerToString) throws IOException {\r\n        outputStream.write(headerToString.headerToString(headerArray).getBytes());\r\n    }\r\n\r\n    private static void outputHeaderToAllRelevantStreams() {\r\n        for (int i = 0; i < outputStreams.size(); i++) {\r\n            HeaderToString headerToString = headerToStringsForOSs.get(i);\r\n            if(headerToString != null){\r\n                try {\r\n                    outputHeaderToStream(outputStreams.get(i), S_Metrics.header, headerToString);\r\n                } catch (IOException e) {\r\n                    handleIO_Exception(e, outputStreams.get(i), headerToStringsForOSs.get(i).headerToString(S_Metrics.header));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void outputInstanceReportToStream(OutputStream outputStream, InstanceReport instanceReport,\r\n                                                     InstanceReportToString instanceReportToString) throws IOException {\r\n        outputStream.write(instanceReportToString.instanceReportToString(instanceReport).getBytes());\r\n    }\r\n\r\n    private static void outputInstanceReportToAllStreams(InstanceReport instanceReport) {\r\n        for (int i = 0; i < outputStreams.size(); i++) {\r\n            try {\r\n                outputInstanceReportToStream(outputStreams.get(i), instanceReport, instanceReportToStringsForOSs.get(i));\r\n            } catch (IOException e) {\r\n                handleIO_Exception(e, outputStreams.get(i), instanceReportToStringsForOSs.get(i).instanceReportToString(instanceReport));\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void outputAllInstanceReportToAllStreams() {\r\n        for (int i = 0; i < outputStreams.size(); i++) {\r\n            OutputStream outputStream = outputStreams.get(i);\r\n            InstanceReportToString iToString = instanceReportToStringsForOSs.get(i);\r\n            InstanceReport currentInstanceReport = null;\r\n            try {\r\n                for (int j = 0; j < S_Metrics.reports.size(); j++) {\r\n                    currentInstanceReport = S_Metrics.reports.get(j);\r\n                    outputInstanceReportToStream(outputStream, currentInstanceReport, iToString);\r\n                }\r\n            } catch (IOException e) {\r\n                handleIO_Exception(e, outputStream, iToString.instanceReportToString(currentInstanceReport));\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void outputAllInstanceReportsToStream(OutputStream outputStream,\r\n                                                         InstanceReportToString instanceReportToString) throws IOException {\r\n        for (InstanceReport report :\r\n                S_Metrics.reports) {\r\n            outputInstanceReportToStream(outputStream, report, instanceReportToString);\r\n        }\r\n    }\r\n\r\n    private static void handleIO_Exception(IOException e, OutputStream outputStream, String data){\r\n        DateFormat dateFormat = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\r\n        Date date = new Date();\r\n\r\n        System.out.println(\"I/O error at time: \" + dateFormat.format(date));\r\n        System.out.println(\"          when writing: \" + data);\r\n        System.out.println(\"          to OutputStream: \" + outputStream.toString());\r\n        System.out.println(\"          printing stack trace:\");\r\n        e.printStackTrace();\r\n    }\r\n\r\n    private static void flushAllOutputStreams() {\r\n        for (OutputStream os :\r\n                outputStreams) {\r\n            try {\r\n                os.flush();\r\n            } catch (IOException e) {\r\n                handleIO_Exception(e, os, \"All data that had not yet been flushed.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private static String[] createHeaderFromCurrentReports(){\r\n        Set<String> headerSet = new HashSet<>();\r\n        for (InstanceReport report :\r\n                S_Metrics.reports) {\r\n            headerSet.addAll(report.getAllFields());\r\n        }\r\n        return headerSet.toArray(String[]::new);\r\n    }\r\n\r\n    ////        OUTPUT API      ////\r\n\r\n    /**\r\n     * Writes the committed {@link InstanceReport} to all the OutputStreams in {@link #outputStreams}\r\n     * @param instanceReport the committed {@link InstanceReport}\r\n     * @throws IOException If an I/O error occurs.\r\n     */\r\n    static void commit(InstanceReport instanceReport) throws IOException {\r\n        outputInstanceReportToAllStreams(instanceReport);\r\n        flushAllOutputStreams();\r\n    }\r\n\r\n    /**\r\n     * Exports all the {@link InstanceReport}s to the given output stream.\r\n     * @param out the OutputStream to write to.\r\n     * @param instanceReportToString the function with which to convert {@link InstanceReport}s to Strings.\r\n     * @param headerToString the function with which to convert the {@link #header} to a String.\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void exportToOutputStream(OutputStream out, InstanceReportToString instanceReportToString, HeaderToString headerToString) throws IOException {\r\n        if(headerToString != null) {\r\n            outputHeaderToStream(out, S_Metrics.header, headerToString);\r\n            for (InstanceReport report :\r\n                    reports) {\r\n                outputInstanceReportToStream(out, report, instanceReportToString);\r\n            }\r\n        }\r\n        out.flush();\r\n    }\r\n\r\n    /**\r\n     * Exports all the {@link InstanceReport}s to the given output stream. Uses default {@link InstanceReportToString}\r\n     * and {@link HeaderToString} methods.\r\n     * @param out the OutputStream to write to.\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void exportToOutputStream(OutputStream out) throws IOException {\r\n        exportToOutputStream(out, S_Metrics::instanceReportToStringCSV, S_Metrics::headerArrayToStringCSV);\r\n        out.flush();\r\n    }\r\n\r\n    /**\r\n     * Exports all the {@link InstanceReport}s to all the saved OutputStreams.\r\n     * If an {@link IOException} occurs with one of the streams, error information will be printed, and the method will\r\n     * move on to the other streams.\r\n     */\r\n    public static void exportAll() {\r\n        outputAllInstanceReportToAllStreams();\r\n        flushAllOutputStreams();\r\n    }\r\n\r\n    /**\r\n     * Exports all the {@link InstanceReport}s to the given OutputStream, in CSV format.\r\n     * @param outputStream the OutputStream to write to. Typically a {@link java.io.FileOutputStream}.\r\n     * @param headerArray the desired header for the CSV output. Only {@link InstanceReport} fields which are contained\r\n     *                    in this header will be written.\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void exportCSV(OutputStream outputStream, String[] headerArray) throws IOException {\r\n        outputHeaderToStream(outputStream, headerArray, S_Metrics::headerArrayToStringCSV);\r\n        outputAllInstanceReportsToStream(outputStream,\r\n                instanceReport -> S_Metrics.instanceReportToStringCSV(instanceReport, S_Metrics.CSV_DELIMITER, headerArray));\r\n        outputStream.flush();\r\n    }\r\n\r\n    /**\r\n     * Exports all the {@link InstanceReport}s to the given OutputStream, in CSV format. Creates a header that contains\r\n     * all fields from all {@link InstanceReport}s.\r\n     * @param outputStream the OutputStream to write to. Typically a {@link java.io.FileOutputStream}.\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void exportCSV(OutputStream outputStream) throws IOException {\r\n        exportCSV(outputStream, createHeaderFromCurrentReports());\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/Environment/Metrics/S_Metrics.java b/src/main/java/Environment/Metrics/S_Metrics.java
--- a/src/main/java/Environment/Metrics/S_Metrics.java	(revision b7dee42a7e06e50107bd2d08be8437bc03f0d8b2)
+++ b/src/main/java/Environment/Metrics/S_Metrics.java	(date 1681984134011)
@@ -177,15 +177,6 @@
         addOutputStream(outputStream, S_Metrics::instanceReportToStringCSV, S_Metrics::headerArrayToStringCSV);
     }
 
-    public static void addSolutionExportOutputStream(String pathName) throws IOException {
-        int index = S_Metrics.getAllReports().size() - 1;
-
-        if (A_RunManager.verifyOutputPath(pathName)) {
-            String fullPathName = pathName + "/" + index + ".txt";
-            addOutputStream(new FileOutputStream(fullPathName), S_Metrics::instanceReportToSolutionString);
-        }
-    }
-
 
     public static void removeOutputStream(OutputStream outputStream){
         int streamIndex = outputStreams.indexOf(outputStream);
@@ -338,6 +329,10 @@
         }
     }
 
+    public static void addSolutionExportOutputStream(String pathName) throws IOException {
+        addOutputStream(new FileOutputStream(pathName), S_Metrics::instanceReportToSolutionString);
+    }
+
     private static void outputInstanceReportToStream(OutputStream outputStream, InstanceReport instanceReport,
                                                      InstanceReportToString instanceReportToString) throws IOException {
         outputStream.write(instanceReportToString.instanceReportToString(instanceReport).getBytes());
Index: src/main/java/BasicMAPF/Instances/Maps/I_Map.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package BasicMAPF.Instances.Maps;\r\n\r\nimport BasicMAPF.Instances.Maps.Coordinates.I_Coordinate;\r\n\r\nimport java.util.Collection;\r\n\r\npublic interface I_Map {\r\n\r\n    /**    /**\r\n     * Returns the {@link I_Location map location} for the given {@link I_Coordinate}.\r\n     * @param i_coordinate the {@link I_Coordinate} of the {@link I_Location map location}.\r\n     * @return the {@link I_Location map location} for the given {@link I_Coordinate}.\r\n     */\r\n    I_Location getMapLocation(I_Coordinate i_coordinate);\r\n\r\n    /**\r\n     * @param i_coordinate the {@link I_Coordinate} to check.\r\n     * @return true if the given coordinate is valid for this map, meaning it is reachable in some way. Note that for\r\n     * a coordinate which could exist given the dimensions of the map, but is not reachable, behaviour is undefined.\r\n     */\r\n    boolean isValidCoordinate(I_Coordinate i_coordinate);\r\n\r\n    /**\r\n     * Creates a new {@link I_Map} from this {@link I_Map}, where some of the locations are removed. They must also be\r\n     * remove from the neighbour lists of all their neighbours.\r\n     * @param mapLocations a collection of location to remove from the map.\r\n     * @return a new {@link I_Map} from this {@link I_Map}, where some of the locations are removed.\r\n     */\r\n    I_Map getSubmapWithout(Collection<? extends I_Location> mapLocations);\r\n\r\n    boolean isStronglyConnected();\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/BasicMAPF/Instances/Maps/I_Map.java b/src/main/java/BasicMAPF/Instances/Maps/I_Map.java
--- a/src/main/java/BasicMAPF/Instances/Maps/I_Map.java	(revision b7dee42a7e06e50107bd2d08be8437bc03f0d8b2)
+++ b/src/main/java/BasicMAPF/Instances/Maps/I_Map.java	(date 1686399449642)
@@ -3,6 +3,7 @@
 import BasicMAPF.Instances.Maps.Coordinates.I_Coordinate;
 
 import java.util.Collection;
+import java.util.HashMap;
 
 public interface I_Map {
 
@@ -28,5 +29,7 @@
      */
     I_Map getSubmapWithout(Collection<? extends I_Location> mapLocations);
 
+    HashMap<I_Coordinate, GraphMapVertex> getAllGraphLocations();
+
     boolean isStronglyConnected();
 }
Index: src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/I_ConstraintGroupingKey.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package BasicMAPF.Solvers.ConstraintsAndConflicts.Constraint;\r\n\r\nimport BasicMAPF.Solvers.Move;\r\n\r\n/**\r\n * replaces the constraint with a key that is quick to find in a set.\r\n */\r\npublic interface I_ConstraintGroupingKey {\r\n\r\n    /**\r\n     * Given some agent's final move (brings it to goal), return true if constraints under this key may be relevant\r\n     * at some point in the future (after this move)\r\n     * @param finalMove an agent's final move in its plan\r\n     * @return true if constraints under this key may be relevant at some point in the future\r\n     */\r\n    boolean relevantInTheFuture(Move finalMove);\r\n\r\n    /**\r\n     * return the time of the key.\r\n     * @return the time of the key.\r\n     */\r\n    int getTime();\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/I_ConstraintGroupingKey.java b/src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/I_ConstraintGroupingKey.java
--- a/src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/I_ConstraintGroupingKey.java	(revision b7dee42a7e06e50107bd2d08be8437bc03f0d8b2)
+++ b/src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/I_ConstraintGroupingKey.java	(date 1685893497010)
@@ -1,5 +1,6 @@
 package BasicMAPF.Solvers.ConstraintsAndConflicts.Constraint;
 
+import BasicMAPF.Instances.Maps.I_Location;
 import BasicMAPF.Solvers.Move;
 
 /**
@@ -20,4 +21,10 @@
      * @return the time of the key.
      */
     int getTime();
+
+    /**
+     * return the location of the key.
+     * @return the location of the key.
+     */
+    I_Location getLocation();
 }
Index: src/main/java/Environment/RunManagers/A_RunManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Environment.RunManagers;\r\n\r\nimport BasicMAPF.Instances.InstanceManager;\r\nimport BasicMAPF.Instances.MAPF_Instance;\r\nimport BasicMAPF.Solvers.I_Solver;\r\nimport Environment.Experiment;\r\nimport Environment.IO_Package.IO_Manager;\r\nimport Environment.Metrics.InstanceReport;\r\nimport Environment.Metrics.S_Metrics;\r\nimport Environment.Visualization.I_VisualizeSolution;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.text.DateFormat;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Objects;\r\n\r\n/**\r\n * This in an abstract class that overcomes the need to comment out lines in the 'Main' method\r\n * Moreover, it focuses the user on what it needs to run an experiment.\r\n * Any RunManager holds a list of {@link I_Solver} and a list of {@link Experiment}\r\n */\r\npublic abstract class A_RunManager {\r\n\r\n    protected List<I_Solver> solvers = new ArrayList<>();\r\n    protected List<Experiment> experiments = new ArrayList<>();\r\n\r\n    public static final String DEFAULT_RESULTS_OUTPUT_DIR = IO_Manager.buildPath(new String[]{System.getProperty(\"user.home\"), \"MAPF_Results\"});\r\n    private final String resultsOutputDir;\r\n    protected String resultsFilePrefix = \"results\";\r\n    protected final I_VisualizeSolution visualizer;\r\n\r\n    protected A_RunManager(String resultsOutputDir, I_VisualizeSolution visualizer) {\r\n        this.resultsOutputDir = Objects.requireNonNullElse(resultsOutputDir, DEFAULT_RESULTS_OUTPUT_DIR);\r\n        verifyOutputPath(this.resultsOutputDir);\r\n        this.visualizer = visualizer;\r\n    }\r\n    protected A_RunManager(String resultsOutputDir) {\r\n        this(resultsOutputDir, null);\r\n    }\r\n\r\n    public static boolean verifyOutputPath(String path) {\r\n        File directory = new File(path);\r\n        if (! directory.exists()){\r\n            boolean created = directory.mkdir();\r\n            if(!created){\r\n                String errString = \"Could not locate or create output directory.\";\r\n                System.out.println(errString);\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    abstract void setSolvers();\r\n    abstract void setExperiments();\r\n\r\n    public void runAllExperiments(){\r\n        setOutputStreamsBeforeRunning();\r\n\r\n        setSolvers();\r\n        setExperiments();\r\n\r\n        for ( Experiment experiment : experiments ) {\r\n\r\n            experiment.runExperiment(solvers);\r\n\r\n            System.out.println(experiment.experimentName + \" - Done!\");\r\n        }\r\n\r\n        System.out.println(\"RunAllExperiments - Done!\");\r\n\r\n        exportAllResults();\r\n\r\n        clearMetrics();\r\n    }\r\n\r\n    public static MAPF_Instance getInstanceFromPath(InstanceManager manager, InstanceManager.InstancePath absolutePath){\r\n        return manager.getSpecificInstance(absolutePath);\r\n    }\r\n\r\n    protected void setOutputStreamsBeforeRunning() {\r\n        // output to stdout while running\r\n        try {\r\n            S_Metrics.addOutputStream(System.out, S_Metrics::instanceReportToHumanReadableString);\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // output (only the following fields) to csv while running\r\n        try {\r\n            S_Metrics.setHeader(new String[]{\r\n                    InstanceReport.StandardFields.experimentName,\r\n                    InstanceReport.StandardFields.mapName,\r\n                    InstanceReport.StandardFields.instanceName,\r\n                    InstanceReport.StandardFields.numAgents,\r\n                    InstanceReport.StandardFields.solver,\r\n                    InstanceReport.StandardFields.solved,\r\n                    InstanceReport.StandardFields.valid,\r\n                    InstanceReport.StandardFields.elapsedTimeMS,\r\n                    InstanceReport.StandardFields.solutionCost,\r\n                    InstanceReport.StandardFields.solution,\r\n                    InstanceReport.StandardFields.startDateTime,\r\n                    InstanceReport.StandardFields.processorInfo,\r\n            });\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        sleepToAvoidOverridingPreviousResultsFiles();\r\n\r\n        DateFormat dateFormat = S_Metrics.defaultDateFormat;\r\n        String pathWithStartTime = IO_Manager.buildPath(new String[]{resultsOutputDir, \"log \" + resultsFilePrefix + \" \" + dateFormat.format(System.currentTimeMillis())}) + \" .csv\";\r\n        try {\r\n            S_Metrics.addOutputStream(new FileOutputStream((pathWithStartTime)));\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n\r\n    protected void exportAllResults() {\r\n        sleepToAvoidOverridingPreviousResultsFiles();\r\n        DateFormat dateFormat = S_Metrics.defaultDateFormat;\r\n        String pathWithEndTime =  IO_Manager.buildPath(new String[]{resultsOutputDir, \"res \" + resultsFilePrefix + \" \" + dateFormat.format(System.currentTimeMillis())}) + \" .csv\";\r\n        try {\r\n            S_Metrics.exportCSV(new FileOutputStream(pathWithEndTime)            );\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private static void sleepToAvoidOverridingPreviousResultsFiles() {\r\n        try {\r\n            Thread.sleep(30);\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    protected static void clearMetrics() {\r\n        S_Metrics.clearAll();\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/Environment/RunManagers/A_RunManager.java b/src/main/java/Environment/RunManagers/A_RunManager.java
--- a/src/main/java/Environment/RunManagers/A_RunManager.java	(revision b7dee42a7e06e50107bd2d08be8437bc03f0d8b2)
+++ b/src/main/java/Environment/RunManagers/A_RunManager.java	(date 1681984442753)
@@ -57,7 +57,7 @@
     abstract void setSolvers();
     abstract void setExperiments();
 
-    public void runAllExperiments(){
+    public void runAllExperiments() {
         setOutputStreamsBeforeRunning();
 
         setSolvers();
@@ -112,13 +112,17 @@
         sleepToAvoidOverridingPreviousResultsFiles();
 
         DateFormat dateFormat = S_Metrics.defaultDateFormat;
-        String pathWithStartTime = IO_Manager.buildPath(new String[]{resultsOutputDir, "log " + resultsFilePrefix + " " + dateFormat.format(System.currentTimeMillis())}) + " .csv";
+
+        String basePath = IO_Manager.buildPath(new String[]{resultsOutputDir, "log " + resultsFilePrefix + " " + dateFormat.format(System.currentTimeMillis())});
+        String pathWithStartTime = basePath + ".csv";
+        String pathWithStartTimeSolution = basePath + ".txt";
+
         try {
             S_Metrics.addOutputStream(new FileOutputStream((pathWithStartTime)));
+            S_Metrics.addSolutionExportOutputStream(pathWithStartTimeSolution);
         } catch (IOException e) {
             e.printStackTrace();
         }
-
     }
 
     protected void exportAllResults() {
@@ -126,7 +130,7 @@
         DateFormat dateFormat = S_Metrics.defaultDateFormat;
         String pathWithEndTime =  IO_Manager.buildPath(new String[]{resultsOutputDir, "res " + resultsFilePrefix + " " + dateFormat.format(System.currentTimeMillis())}) + " .csv";
         try {
-            S_Metrics.exportCSV(new FileOutputStream(pathWithEndTime)            );
+            S_Metrics.exportCSV(new FileOutputStream(pathWithEndTime));
         } catch (IOException e) {
             e.printStackTrace();
         }
Index: src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/TimeLocation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package BasicMAPF.Solvers.ConstraintsAndConflicts.Constraint;\r\n\r\nimport BasicMAPF.Instances.Maps.I_Location;\r\nimport BasicMAPF.Solvers.Move;\r\n\r\npublic class TimeLocation implements I_ConstraintGroupingKey {\r\n    public final I_Location location;\r\n    public final int time;\r\n\r\n    public TimeLocation(Constraint constraint) {\r\n        this.location = constraint.location;\r\n        this.time = constraint.time;\r\n    }\r\n\r\n    public TimeLocation(Move move){\r\n        this.location = move.currLocation;\r\n        this.time = move.timeNow;\r\n    }\r\n\r\n    public TimeLocation(TimeLocation toCopy){\r\n        this.location = toCopy.location;\r\n        this.time = toCopy.time;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (!(o instanceof TimeLocation)) return false;\r\n\r\n        TimeLocation that = (TimeLocation) o;\r\n\r\n        if (time != that.time) return false;\r\n        return location.equals(that.location);\r\n\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = location.hashCode();\r\n        result = 31 * result + time;\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public boolean relevantInTheFuture(Move finalMove) {\r\n        return this.time > finalMove.timeNow && this.location.equals(finalMove.currLocation);\r\n    }\r\n\r\n    @Override\r\n    public int getTime() {\r\n        return this.time;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/TimeLocation.java b/src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/TimeLocation.java
--- a/src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/TimeLocation.java	(revision b7dee42a7e06e50107bd2d08be8437bc03f0d8b2)
+++ b/src/main/java/BasicMAPF/Solvers/ConstraintsAndConflicts/Constraint/TimeLocation.java	(date 1685890645525)
@@ -50,4 +50,9 @@
     public int getTime() {
         return this.time;
     }
-}
+
+    @Override
+    public I_Location getLocation() {
+        return this.location;
+    }
+}
\ No newline at end of file
