package BasicMAPF.Solvers.PrioritisedPlanningWithGuarantees;

import BasicMAPF.DataTypesAndStructures.*;
import BasicMAPF.DataTypesAndStructures.MDDs.*;
import BasicMAPF.Instances.Agent;
import BasicMAPF.Instances.MAPF_Instance;
import BasicMAPF.Instances.Maps.I_Location;
import BasicMAPF.Instances.Maps.I_Map;
import BasicMAPF.Solvers.AStar.CostsAndHeuristics.SingleAgentGAndH;
import BasicMAPF.Solvers.AStar.CostsAndHeuristics.DistanceTableSingleAgentHeuristic;
import BasicMAPF.DataTypesAndStructures.TimeInterval;
import BasicMAPF.Solvers.A_Solver;
import BasicMAPF.Solvers.ConstraintsAndConflicts.A_Conflict;
import BasicMAPF.Solvers.ConstraintsAndConflicts.Constraint.Constraint;
import BasicMAPF.Solvers.ConstraintsAndConflicts.Constraint.ConstraintSet;
import BasicMAPF.Solvers.ConstraintsAndConflicts.Constraint.GoalConstraint;
import BasicMAPF.Solvers.ConstraintsAndConflicts.Constraint.I_ConstraintSet;
import Environment.Config;
import Environment.Metrics.InstanceReport;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;

public class PriorityConstrainedSearch extends A_Solver {

    /* = Constants = */

    /* = Class Instance Fields = */

    /**
     * A queue of open {@link PCSNode nodes/states}. Also referred to as OPEN.
     */
    public final I_OpenList<PCSNode> openList;
    public final I_MDDSearcherFactory searcherFactory;
    MDDManager mddManager;
    /**
     * Determines how to sort {@link #openList OPEN}.
     */
    private final Comparator<? super PCSNode> nodeComparator;
    private final boolean useSimpleMDDCache;
    private final int MDDCacheDepthDeltaMax;
    private final boolean usePartialGeneration;
    private final I_PCSHeuristic pcsHeuristic;

    /* = Run Fields = */

    MAPF_Instance currentInstance;
    I_Map currentMap;
    /**
     * The agents in the order of their priority.
     */
    Agent[] priorityOrderedAgents;
    /**
     * A {@link SingleAgentGAndH heuristic} for the low level solver.
     */
    private SingleAgentGAndH singleAgentHeuristic;
    /**
     * Initial constraints given to the solver to work with.
     */
    private I_ConstraintSet initialConstraints;
    /**
     * A mapping from agents to their indices in the priority order.
     * // todo fancy array using agent IDs as indices?
     */
    private Map<Agent, Integer> agentIndices;
    private int runningNodeID;
    private int cLowerBound;
    /**
     * The number of {@link PCSNode nodes} generated by the solver, including partially generated nodes.
     */
    private int generatedNodesIncludingPartial;
    PriorityConstrainedSearch(@Nullable I_OpenList<PCSNode> openList, @Nullable Comparator<? super PCSNode> nodeComparator,
                              @Nullable I_MDDSearcherFactory searcherFactory, @Nullable Boolean useSimpleMDDCache,
                              @Nullable Integer MDDCacheDepthDeltaMax, @Nullable Boolean usePartialGeneration, I_PCSHeuristic pcsHeuristic) {
        this.nodeComparator = Objects.requireNonNullElse(nodeComparator, PCSCompTieBreakSmallerMDDs.defaultInstance);
        this.openList = Objects.requireNonNullElseGet(openList, () -> new OpenListTree<>(this.nodeComparator));
        this.searcherFactory = Objects.requireNonNullElseGet(searcherFactory, AStarFactory::new);

        this.useSimpleMDDCache = Objects.requireNonNullElse(useSimpleMDDCache, true);
        this.MDDCacheDepthDeltaMax = Objects.requireNonNullElse(MDDCacheDepthDeltaMax, 1);
        this.usePartialGeneration = Objects.requireNonNullElse(usePartialGeneration, true);
        this.pcsHeuristic = Objects.requireNonNullElseGet(pcsHeuristic, PCSHeuristicSIPP::new);

        super.name = "Priority Constrained Search";
    }

    /*  = initialization =  */

    @Override
    protected void init(MAPF_Instance instance, RunParameters runParameters) {
        super.init(instance, runParameters);
        this.currentInstance = instance;
        this.currentMap = instance.map;
        this.priorityOrderedAgents = runParameters.priorityOrder != null ? runParameters.priorityOrder :
                instance.agents.toArray(new Agent[0]);
        if (this.priorityOrderedAgents.length != instance.agents.size()){
            throw new IllegalArgumentException("Priority order array must cover exactly the same set of agents that exist in the instance");
        }
        if (Config.DEBUG >= 2 &&  ! Set.of(this.priorityOrderedAgents).equals(new HashSet<>(instance.agents))){
            throw new IllegalArgumentException("Priority order array must cover exactly the same set of agents that exist in the instance: \n" +
                    Arrays.toString(this.priorityOrderedAgents) + "\nvs\n" + instance.agents);
        }
        this.singleAgentHeuristic = runParameters.singleAgentGAndH != null ? runParameters.singleAgentGAndH :
                new DistanceTableSingleAgentHeuristic(Arrays.asList(priorityOrderedAgents), this.currentInstance.map);
        this.initialConstraints = Objects.requireNonNullElseGet(runParameters.constraints, ConstraintSet::new);
        this.agentIndices = new HashMap<>();
        for (int i = 0; i < priorityOrderedAgents.length; i++) {
            agentIndices.put(priorityOrderedAgents[i], i);
        }
        this.runningNodeID = 0;
        this.cLowerBound = Integer.MIN_VALUE;
        this.expandedNodes = 0;
        this.mddManager = new MDDManager(searcherFactory, getTimeout(), singleAgentHeuristic);
        this.generatedNodesIncludingPartial = 0;
    }

    /*  = algorithm =  */

    @Override
    protected Solution runAlgorithm(MAPF_Instance instance, RunParameters parameters) {
        generateRoot();
        PCSNode goalNode = mainLoop();
        return solutionFromGoal(goalNode);
    }

    private void generateRoot() {
        PCSNode root = generateNode(null, null, false);
        addToOpen(root);
    }

    private void addToOpen(@Nullable PCSNode node) {
        if (node != null){
            openList.add(node);
        }
    }

    private PCSNode mainLoop() {
        while(!checkTimeout() && !openList.isEmpty()) {
            PCSNode node = openList.poll();
            // todo closed list?
            if (isPartiallyGenerated(node)){
                // continue generating the node
                PCSNode continuedNode = continueAddingAgents(node.MDDs(), new ArrayList<>() /*for now, misses the already added constraints because we don't save them and don't use them for anything*/,
                        node.constraints());
                addToOpen(continuedNode);
            }
            else if (isGoal(node))
                return node;
            else
                expandNode(node);
        }
        return null;
    }

    private boolean isPartiallyGenerated(PCSNode node) {
        return node.conflict() == null && node.MDDs().size() < priorityOrderedAgents.length;
    }

    private boolean isGoal(PCSNode node) {
        return node.MDDs().size() == priorityOrderedAgents.length && node.conflict() == null;
    }

    private Solution solutionFromGoal(PCSNode goalNode) {
        if (goalNode == null){
            return null;
        }
        Solution solution = new Solution();
        for (MDD mdd: goalNode.MDDs()) {
            Agent agent = mdd.getAgent();
            SingleAgentPlan plan = new SingleAgentPlan(agent);
            MDDNode prevNode = mdd.getStart();
            // any arbitrary walk down the MDD would give a plan, and any plan would be valid
             while (! prevNode.equals(mdd.getGoal())){
                 MDDNode nextNode = prevNode.getNeighbors().get(0);
                 plan.addMove(new Move(agent, nextNode.getDepth() // assumes depth := time
                         , prevNode.getLocation(), nextNode.getLocation()));
                 prevNode = nextNode;
             }
            solution.putPlan(plan);
        }
        return solution;
    }

    private void expandNode(PCSNode node) {
        if (cLowerBound > node.getF()){
            throw new IllegalStateException("Lower bound should not decrease during search unless the heuristic is inconsistent or there is a bug. " +
                    "Lower bound: " + cLowerBound + ", node f: " + node.getF() + ", node: " + node);
        }
        cLowerBound = node.getF();

        expandedNodes++;
        Agent leastPriorityAgent = node.getLeastPriorityMDD().getAgent();
        Agent higherPriorityAgent = node.conflict().agent1.equals(leastPriorityAgent) ?
                node.conflict().agent2 : node.conflict().agent1;
        Constraint[] preventingConstraintsCBSStyle = node.conflict().getPreventingConstraints();
        if (preventingConstraintsCBSStyle.length != 2){
            throw new IllegalStateException("Expected 2 preventing constraints, got " + preventingConstraintsCBSStyle.length);
        }
        Constraint constraintOnHighPriorityAgent = preventingConstraintsCBSStyle[0].agent.equals(higherPriorityAgent) ?
                preventingConstraintsCBSStyle[0] : preventingConstraintsCBSStyle[1];


        // left node - positive constraint on the higher priority agent
        PCSNode leftNode = generateNode(node, constraintOnHighPriorityAgent, true);
        // right node - negative constraint on the higher priority agent
        PCSNode rightNode = generateNode(node, constraintOnHighPriorityAgent, false);
//        node.setChildren(new PCSNode[]{leftNode, rightNode});

        // todo duplicate detection in open?
        // todo closed list?
        addToOpen(leftNode);
        addToOpen(rightNode);
    }

    @Nullable
    private PCSNode generateNode(@Nullable PCSNode parent,@Nullable Constraint newConstraintOnHighPriorityAgent,
                                 boolean isPositiveConstraint) {
        if (parent == null && newConstraintOnHighPriorityAgent != null){
            throw new IllegalArgumentException("Can't have a new constraint on the high priority agent in the root node");
        }
        if (parent != null && newConstraintOnHighPriorityAgent == null){
            throw new IllegalArgumentException("Must have a new constraint on the high priority agent in a non-root node");
        }
        if (Config.INFO >= 2) System.out.println("Generating node with constraint " + newConstraintOnHighPriorityAgent + " and isPositiveConstraint=" + isPositiveConstraint);

        ConstraintSet updatedConstraints = new ConstraintSet(parent != null ? parent.constraints() : new ConstraintSet(initialConstraints));
        List<Constraint> addedConstraints = new ArrayList<>();
        ArrayList<MDD> MDDs = new ArrayList<>(parent != null ? parent.MDDs(): Collections.emptyList());

        if (parent == null){
            // root only
            MDD firstMDD = getInitialMDDForAgent(priorityOrderedAgents[0], initialConstraints);
            if (firstMDD == null){ // timeout or initial constraints
                if (Config.DEBUG >= 1 && ! initialConstraints.isEmpty() && ! checkTimeout()){
                    throw new IllegalStateException("Should not fail to build the first MDD when there are no initial constraints, except for due to timeout");
                }
                return null;
            }
            MDDs.add(firstMDD);
        }
        else {
            // handle high-priority agent first -
            // it might generate new constraints on lower priority agents because of new critical resources
            MDD constrainedHighPriorityMDD = parent.MDDs().get(agentIndex(newConstraintOnHighPriorityAgent.agent))
                    .shallowCopyWithConstraint(newConstraintOnHighPriorityAgent, isPositiveConstraint);
            if (Config.DEBUG >= 1 && constrainedHighPriorityMDD == null){
                throw new IllegalStateException("Should not get a constraint on high priority MDD that severs it if all " +
                        "critical resources were preemptively added as constraints on the lower priority agents.");
            }
            MDDs.set(agentIndex(newConstraintOnHighPriorityAgent.agent), constrainedHighPriorityMDD);
            List<Constraint> criticalResourceConstraints = getCriticalResourcesAsNegativeConstraints(constrainedHighPriorityMDD);
            updatedConstraints.addAll(criticalResourceConstraints); // relies on ConstraintSet's set behavior to handle duplicates
            addedConstraints.addAll(criticalResourceConstraints);

            if (!addedConstraints.isEmpty()){
                // get an MDD (or view) that obeys the constraints, including the new constraints, of the least priority MDD
                MDD compliantMDD = parent.getLeastPriorityMDD().deepCopyWithConstraints(updatedConstraints);
                if (compliantMDD.getDepth() == -1){ // impossible at current depth, so deepen.
                    compliantMDD = deeperMDD(parent.getLeastPriorityMDD().getAgent(), updatedConstraints,
                            currentMap.getMapLocation(parent.getLeastPriorityMDD().getAgent().source),
                            currentMap.getMapLocation(parent.getLeastPriorityMDD().getAgent().target),
                            parent.getLeastPriorityMDD().getDepth());
                    if (compliantMDD == null){ // impossible at any depth, or timeout
                        return null;
                    }
                }
                MDDs.set(MDDs.size() - 1, compliantMDD);
            }
        }

        generatedNodesIncludingPartial++;
        // finished handling the direct consequences of the new constraints, now see if there are still conflicts, or agents can be added
        return continueAddingAgents(MDDs, addedConstraints, updatedConstraints);
    }

    @Nullable
    private PCSNode continueAddingAgents(ArrayList<MDD> MDDs, List<Constraint> addedConstraints, ConstraintSet updatedConstraints) {
        // todo switch to creating a mutable node and adding to it every time instead of creating a new one every time?
        int g = getG(MDDs);
        int[] harr = getHarr(MDDs, updatedConstraints);
        if (harr == null){ // if using a smart heuristic that might detect a node already can't lead to a solution
            return null;
        }
        int h = Arrays.stream(harr).sum();
        A_Conflict conflict;
        int addedAgents = 0;
        // continue adding agents and their MDDs while there are no conflicts
        while ((conflict = earliestConflictWithLeastPriorityMDD(MDDs)) == null && MDDs.size() < priorityOrderedAgents.length
                /*check fmin (partial generation)*/ && (!usePartialGeneration || openList.isEmpty() || g + h <= openList.peek().getF())) {
            if (checkTimeout()){
                return null;
            }
            // done with this MDD - add all its critical resources as negative constraints
            List<Constraint> criticalResourceConstraints = getCriticalResourcesAsNegativeConstraints(MDDs.get(MDDs.size() - 1));
            addedConstraints.addAll(criticalResourceConstraints);
            updatedConstraints.addAll(criticalResourceConstraints);

            // next least-priority agent
            Agent nextAgent = priorityOrderedAgents[MDDs.size()];
            MDD nextAgentMDD = getInitialMDDForAgent(nextAgent, updatedConstraints);
            if (nextAgentMDD == null){ // unsolvable at any depth under current constraints, or timeout
                return null;
            }
            MDDs.add(nextAgentMDD);
            addedAgents++;
            if (nextAgentMDD.getDepth() < harr[addedAgents - 1]){
                throw new IllegalStateException("Inconsistent heuristic! MDD depth is less than the heuristic value. " +
                        "MDD depth: " + nextAgentMDD.getDepth() + ", heuristic value: " + harr[addedAgents - 1] + ", agent: " + nextAgent + ", MDDs: " + MDDs);
            }
            g += nextAgentMDD.getDepth();
            h -= harr[addedAgents - 1];
        }

        if (conflict != null || MDDs.size() == priorityOrderedAgents.length){
            generatedNodes++;
        }
        return new PCSNode(MDDs, g, h, updatedConstraints, conflict, runningNodeID++);
    }

    @Nullable
    private int[] getHarr(ArrayList<MDD> MDDs, ConstraintSet updatedConstraints) {
        Map<I_Location, List<TimeInterval>> safeIntervalsByLocation = null;
        if (pcsHeuristic instanceof PCSHeuristicSIPP){
            safeIntervalsByLocation = updatedConstraints.vertexConstraintsToSortedSafeTimeIntervals(null, this.currentMap);
        }
        return pcsHeuristic.getH(priorityOrderedAgents, MDDs.size(), updatedConstraints, currentInstance, singleAgentHeuristic, safeIntervalsByLocation);
    }

    private List<Constraint> getCriticalResourcesAsNegativeConstraints(MDD positivelyConstrainedHighPriorityMDD) {
        // todo optimize by not generating constraints that exist?
        // todo optimize by incorporating this with the MDD pruning process?
        List<Constraint> res = new ArrayList<>();
        for (int time = 0; time <= positivelyConstrainedHighPriorityMDD.getDepth(); time++) { // assumes depth := time
            List<MDDNode> level = positivelyConstrainedHighPriorityMDD.getLevel(time);
            if (level.size() == 1){
                MDDNode singularNode = level.get(0);
                // add vertex constraint (add even for depth 0, which should not have any effect)
                res.add(new Constraint(null, time, singularNode.getLocation()));
                // add edge constraint
                if (singularNode.getNeighbors().size() == 1){
                    MDDNode neighbor = singularNode.getNeighbors().get(0);
                    res.add(new Constraint(null, time+1, neighbor.getLocation(), singularNode.getLocation())); // reverse the edge to create the constraint
                }
            }
        }
        // target constraint
        res.add(new GoalConstraint(null, positivelyConstrainedHighPriorityMDD.getDepth()+1 // assumes depth := time, starts after reaching target
                , positivelyConstrainedHighPriorityMDD.getGoal().getLocation(), positivelyConstrainedHighPriorityMDD.getAgent()));
        return res;
    }

    private A_Conflict earliestConflictWithLeastPriorityMDD(ArrayList<MDD> MDDs) {
        MDD leastPriorityMDD = MDDs.get(MDDs.size() - 1);
        // todo have a set of the nodes in each MDD and use it to completely skip MDDs that have no suspicion of overlap with the least-priority MDD?
        int deepestDepth = 0;
        for (MDD mdd: MDDs) {
            if (mdd == null){
                throw new IllegalStateException("Should not have null MDDs in the MDD list: " + MDDs);
            }
            deepestDepth = Math.max(deepestDepth, mdd.getDepth());
        }

        int d =
//                // todo if the parent had the same least-priority agent and this MDD had only shrunk, skip levels that we already fully checked?
//                parent != null && parent.getLeastPriorityMDD().getAgent().equals(leastPriorityMDD.getAgent())
//                && parent.getLeastPriorityMDD().getDepth() == leastPriorityMDD.getDepth() ?
//                parent.conflict().time
//                :
                1;
        for (; d <= deepestDepth ; d++) {
            for (int i = 0; i < MDDs.size() - 1; // each MDD that precedes the least-priority MDD
                 i++) {
                if (leastPriorityMDD.getDepth() < d && MDDs.get(i).getDepth() < d){ // todo can we upgrade this to an "or" once we proactively add target constraints?
                    continue; // not critical - checking will be quick anyway
                }
                // check d level of both MDDs for vertex conflicts, and for swapping conflicts with level d-1
                List<A_Conflict> conflicts = leastPriorityMDD.conflictsWithMDDAtDepth(MDDs.get(i), d, true);
                if (! conflicts.isEmpty()){
                    return conflicts.get(0);
                }
            }
        }
        return null;
    }

    private MDD getMinMDD(Agent agent, @NotNull I_ConstraintSet constraints) {
        // todo canonize MDDs so that MDDs that happen to be equal don't take up space?
        return mddManager.getMinMDDNoReuse(currentMap.getMapLocation(agent.source), currentMap.getMapLocation(agent.target), agent, constraints);
    }

    private MDD getInitialMDDForAgent(Agent newlyAddedAgent, @NotNull I_ConstraintSet constraints) {
        if (!useSimpleMDDCache){
            return getMinMDD(newlyAddedAgent, constraints);
        }
        // todo canonize MDDs so that MDDs that happen to be equal don't take up space?
        I_Location source = currentMap.getMapLocation(newlyAddedAgent.source);
        I_Location target = currentMap.getMapLocation(newlyAddedAgent.target);
        int minDepth = singleAgentHeuristic.getHToTargetFromLocation(newlyAddedAgent.target, source);
        // get MDD from a cache of unconstrained MDDs (generate if absent), check if it conflicts with an existing constraint.
        MDD unconstrainedMDD = getUnconstrainedMddAtDepth(newlyAddedAgent, source, target, minDepth);
        if (unconstrainedMDD == null){ // should only be because of timeout
            return null;
        }
        if (MDDCacheDepthDeltaMax == 1){
            mddManager.clearSearchers();
        }
        if (unconstrainedMDD.acceptedBy(constraints)){
            return unconstrainedMDD;
        }
        else {
            // if it conflicts, create a constrained copy and see if it's possible.
            MDD constrainedMDD = unconstrainedMDD.deepCopyWithConstraints(constraints);
            if (constrainedMDD.getDepth() != -1){ // possible at current depth
                return constrainedMDD;
            }
            else { // impossible at current depth
                return deeperMDD(newlyAddedAgent, constraints, source, target, minDepth);
            }
        }
    }

    private MDD getUnconstrainedMddAtDepth(Agent newlyAddedAgent, I_Location source, I_Location target, int requestedDepth) {
        MDD unconstrainedMDD = mddManager.getMDD(source, target, newlyAddedAgent, requestedDepth);
        if (checkTimeout()){
            return null;
        }
        else if (unconstrainedMDD == null){
            throw new IllegalStateException("Should not fail to build an MDD without constraints, assuming the requested depth was more than the minimal depth. " +
                    "\nrequestedDepth: " + requestedDepth + "\nnewlyAddedAgent:" + newlyAddedAgent + "\nsource:" + source +
                    "\ntarget:" + target + "\nminimalDepthFromHeuristic:" + singleAgentHeuristic.getHToTargetFromLocation(newlyAddedAgent.target, source));
        }
        return unconstrainedMDD;
    }

    private MDD deeperMDD(Agent agent, @NotNull I_ConstraintSet constraints, I_Location source, I_Location target, int currentImpossibleDepth) {
        if (!useSimpleMDDCache || MDDCacheDepthDeltaMax == 1){
            return getMinMDD(agent, constraints);
        }
        // get a +1 deeper unconstrained MDD from the cache (generate if absent), check if it still conflicts
        MDD unconstrainedMDD = getUnconstrainedMddAtDepth(agent, source, target, currentImpossibleDepth + 1);
        if (unconstrainedMDD == null){ // should only be because of timeout
            return null;
        }
        if (unconstrainedMDD.acceptedBy(constraints)){
            return unconstrainedMDD;
        }
        else { // If it conflicts, search for min MDD under constraints.
            return getMinMDD(agent, constraints);
        }
    }

    private int agentIndex(Agent agent) {
        return agentIndices.get(agent);
    }

    private int getG(ArrayList<MDD> mdds) {
        int g = 0;
        for (MDD mdd: mdds) {
            g += mdd.getDepth();
        }
        return g;
//        // start with parent's g, remove (parent's) least-priority agent's MDD depth, add that agent's new MDD depth and the new agents' MDD depth
//        int g = parent != null ? parent.g() - parent.getLeastPriorityMDD().getDepth() : 0;
//        for (int i = parent != null ? parent.MDDs().size() - 1 : 0; i < MDDs.size(); i++) {
//            g += MDDs.get(i).getDepth();
//        }
//        return g;
    }

    private int getFreeSpaceH(int numMDDsInNode) {
        // todo derive H by decreasing H from parent?
        int res = 0;
        for (int i = numMDDsInNode; i < priorityOrderedAgents.length; i++) {
            Agent agent = priorityOrderedAgents[i];
            I_Location source = currentMap.getMapLocation(agent.source);
            res += singleAgentHeuristic.getHToTargetFromLocation(agent.target, source);
        }
        return res;
    }

    /*  = wind down =  */

    @Override
    protected void writeMetricsToReport(Solution solution) {
        super.totalLowLevelNodesExpanded = mddManager.getExpandedNodesNum();
        super.totalLowLevelNodesGenerated = mddManager.getGeneratedNodesNum();
        super.writeMetricsToReport(solution);

        super.instanceReport.putIntegerValue("partiallyGeneratedNodes", this.generatedNodesIncludingPartial - this.generatedNodes);
        if(solution != null){
            super.instanceReport.putStringValue(InstanceReport.StandardFields.solutionCostFunction, "SOC");
            super.instanceReport.putFloatValue(InstanceReport.StandardFields.solutionCost, solution.sumIndividualCosts());
        }
    }

    @Override
    protected void releaseMemory() {
        super.releaseMemory();
        this.openList.clear();
        this.currentInstance = null;
        this.currentMap = null;
        this.priorityOrderedAgents = null;
        this.initialConstraints = null;
        this.agentIndices = null;
        this.singleAgentHeuristic = null;
        this.mddManager = null;
    }

    /* = subclasses = */

    public static class DEFAULT_COMPARATOR implements Comparator<PCSNode> {
        @Override
        public int compare(PCSNode o1, PCSNode o2) {
            int res = Integer.compare(o1.getF(), o2.getF());
            if (res != 0){
                return res;
            }
            res = Integer.compare(o2.g(), o1.g()); // reversed to prefer higher g
            if (res != 0){
                return res;
            }
            return Integer.compare(o1.uniqueID(), o2.uniqueID());
        }
    }

    private final static DEFAULT_COMPARATOR DEFAULT_COMPARATOR_INSTANCE = new DEFAULT_COMPARATOR();
}
